
\chapter{Framework Architecture}

\section{Used Technologies}
What we used and why.
\begin{itemize}
\item zdoom, whole table with alternatives alternatives (full page)
\item linux focus, cpp core, python wrapper
\item acs scripting in doombuilder 2 for scenarios
\item python and lasagne for experiments
\end{itemize}

\section{Architecture}\label{sec:architecture}
	\begin{figure}
			\centering
			\includegraphics[scale=0.25]{architecture_diagram.png}
			\caption{Architecture of Vizia Environment.}\label{fig:architecture_diagram}
	\end{figure}

The main components of Vizia environament:
    \begin{itemize}
    \item Vizia library --- which provides a DoomGame API that allows user to configure, launch and play the game in several flow control modes.
    \item ViziaZDoom --- modified ZDoom engine with a Vizia module to communicate with a DoomGame object, control the game flow and adding additional rendering modes. It can act as a process under the control of the DoomGame object, Dome engine used for testing in Doom editors or as standalone process.
    \item Python and Java bindings - allowing the use of the DoomGame API in these languages.
    \end{itemize}


\subsection{The separate API and game processes}\label{sec:architecture_separate_processes}

When the user initiates the processing, the DoomGame object creates a second thread that starts ViziaZDoom process with the appropriate settings and supervises it. From this point the API and the game communicate using only a shared memory.


\subsection{Shared memory to communicate}\label{sec:architecture_shared_memory}

During initialization set of spaces are created in the shared memory space, which includes:
    \begin{itemize}
    \item A Pair of message queues to control the processing flow, and sending messages to the game.
    \item A Shared memory area  to exchange information about game input status. Both the API process and the game process reads and writes to shared memory.
    \item Shared memory areas where the game provides state of the game. These are the values of the variables games necessary to control the processing variables and a copy provided to you buffor wyrenderowanego in the game image. The game process saves to the memory, the process of API support.
    \end{itemize}
All shared memory spaces have unique names for each DoomGame object, which allows the coexistence of multiple instances.


\subsection{Vizia module inside ViziaZDoom}\label{sec:architecture_inside_viziazdoom}

Vizja module inside the engine initializes the shared memory to exchange information with this instance of the game. Then controls the flow of the game depending on the processing mode, and received messages and determines the following processing steps:

    \begin{itemize}
    \item Starting processing of the next game tic.
    \item Transmiting commands from the message queue to the game console.
    \item Sending inputu information from shared memory to the game console.
    \item Processing of events that the game window recieved since the last tic.
    \item Rendering the current frame.
    \item Updating the information about the current game state in the shared memory.
    \end{itemize}

\subsection{Flow control modes}\label{sec:architecture_modes}

The DoomGame API implements four flow control modes:
    
    \begin{itemize}
    \item Synchronous player
    \item Synchronous spectator
    \item Asynchronous player
    \item Asynchronous spectator
    \end{itemize}
    
    \subsubsection{Synchronous player mode}\label{sec:architecture_player_mode}
    
        \begin{figure}
			    \centering
			    \includegraphics[scale=0.25]{player_mode_diagram.png}
			    \caption{Processing flow in synchronous player mode.}\label{fig:player_mode_diagram}
	    \end{figure}
        
	    Synchronous player mode provides synchronous communication between the process that uses the API and the game process. It allows AI agent to make actions as a player. 
	    
	    In this mode, the API and the game processes communicates every tic and are waiting for each other. The game process waits until the API sends a message requesting processing of the next tic and optional update. The game process, after receiving the message, sends input information (AI agent's action) to the game console, process next game tic, and if update was requested renders the current frame and updates the information about the current game state in the shared memory. After this the game process sends a message about completing request and starts waiting for the message processing of the next tic. The process that uses the API waits for the message about completing request.
	    
	    This mode is designed for the singleplayer, the multiplayer will not work correctly - the game net code is disabled in this mode.

    \subsubsection{Synchronous spectator mode}\label{sec:architecture_spectator_mode}

	    \begin{figure}
			    \centering
			    \includegraphics[scale=0.25]{spectator_mode_diagram.png}
			    \caption{Processing flow in synchronous spectator mode.}\label{fig:spectator_mode_diagram}
	    \end{figure}
	    
	    Synchronous spectator mode provides synchronous communication between the process that uses the API and the game process. It allows AI agent to observe a human player's actions. 
	    
	    In this mode the API and the game processes communicates every tic and are waiting for each other. The game process waits until the API sends a message requesting processing of the next tic and optional update. The game process, after receiving the message, process the window input events that have taken place since the last update request (last human player's action), updates the input information in the shared memory, process next game tic and if update was requested renders the current frame and updates the information about the current game state in the shared memory. After this the game process sends a message about completing request and starts waiting for the message processing of the next tic. The process that uses the API waits for the message about completing request.

        Before processing of the next game tic the delay may be introduced in order to ensure the maximum processing speed of 35 tics per second (designed Doom ticrate).
        
        This mode is designed for the singleplayer, the multiplayer will not work correctly - the game network code is disabled in this mode.

    \subsubsection{Asynchronous player mode}\label{sec:architecture_async_player_mode}

	    \begin{figure}
			    \centering
			    \includegraphics[scale=0.25]{async_player_mode_diagram.png}
			    \caption{Processing flow in asynchronous player mode.}\label{fig:async_player_mode_diagram}
	    \end{figure}
	    
	    Asynchronous player mode provides asynchronous communication between the process that uses the API and the game process. It allows AI agent to make actions as a player. 
	    
	    In this mode, the game process continuously process the game tics a constant speed of 35 tics per second (designed Doom ticrate) without waiting for the API process. The API can send a message requesting update. Before each tic the game process checks if it received a message requesting update. After receiving such the message, it sends the input information (AI agent's action) to the game console, process next game tic, updates the information about the current game state in the shared memory, sends a message about completing request and continues processing of the game tics. The process that uses the API waits for the message about completing request.
	    
	    In this mode, both the singleplayer as well as the multiplayer will work correctly - the game network code is disabled in this mode.

    \subsubsection{Asynchronous spectator mode}\label{sec:architecture_async_spectator_mode}

	    \begin{figure}
			    \centering
			    \includegraphics[scale=0.25]{async_spectator_mode_diagram.png}
			    \caption{Processing flow in asynchronous spectator mode.}\label{fig:async_spectator_mode_diagram}
	    \end{figure}
	    
	    Asynchronous spectator mode provides asynchronous communication between the process that uses the API and the game process.It allows AI agent to observe a human player's actions. 
	    
	    In this mode, the game process continuously process the game tics at a constant speed of 35 tics per second (designed Doom ticrate) without waiting for the API process. The API can send a message requesting update. Before each tic the game process checks if it received a message. After receiving such the message, it updates the input information in the shared memory (last human player's action), process next game tic, updates the information about the current game state in the shared memory, sends a message about completing request and continues processing of the game tics. The process that uses the API waits for the message about completing request.

        In this mode processing of the window input events and rendering is performed in each tic.
        
        In this mode, both the singleplayer as well as the multiplayer will work correctly.

\section{Explanation of problems and solutions}\label{sec:architecture_solutions}

\subsubsection{Why separate doom executable?}

Doom engine was designed as standalone executable. It has a diffrent entry point for every operating system and a lot of exit points what makes it difficult to pack it inside library without making any fundamental changes in it's code, in addition, this approach would not give any additional benefits. Also, leaving the Doom engine as a separate executable allows to use it with Doom editors and as standalone Doom engine for testing scenarios.

\subsubsection{Why shared memory to communicate?}

Shared memory is the fastest way to transfer large amounts of data and allows to use this data witout additional copying and processing. 
Because the game process uses shared memory only at the API request (and the API is waiting for completion of it) additional access control mechanism is not needed.

\subsubsection{Zbuffer}

Zostawiam Ci to Grzesiu. //TO DO

\subsubsection{Why multiplayer will not work in synchronous modes?}

Doom engine uses a peer-to-peer communication in multiplayer and requires tight synchronization between all game clients based on real time.
In synchronous modes time when next tic will be processed is unknown - too slow or too fast processing leads to synchronization and unpredictable behaviors and errors in processing. Therefore, the game network code has been disabled in synchronous modes.

\subsubsection{Why OSX is not supported?}

All Vizia environment code is OSX compatible. Due to the lack of access to OSX machine developers have not tested build system for it.

\subsubsection{Why game and scenario files are separated?}

Doom engine uses diffrent type of files for storing data and resources. (WAD and PK3 files) It allows to load main game resources from one file and many additional (scenario) resources from separate files. 

\section{Performance}
Table with some fps ratings and a graph.
Conclusions: it's fast enough, any reasonably good AI will be much slower during learning process.



