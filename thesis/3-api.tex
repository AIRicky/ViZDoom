\chapter{Application Programming Interface}\label{ch:api}
\section{Methods}\label{sec:methods}
	\subsection{Configuration}\label{subsec:config_methods}
	Methods described in this section set main parameters of the environment, such as resolution of generated image or available actions. They should be invoked after creation and before invoking of the initialization method (init). Any attempt to call them after initialization will result in a warning or an exception, depending on severity of consequences. 
	\vspace{20pt}

\begin{clinee}
DoomGame();
\end{clinee}

Constructor that creates an instance of the game. Zdoom is not ready for using after creation and needs initialization. Freshly created DoomGame is initialized with the following parameters:
%maybe some reference to where we describe what it all means . . .if we do anywhere . . .
	\begin{itemize}
		\item screenResolution: RES\_320x240
		\item screenFormat: CRCGCB
		\item Game path: ``./viziazdoom''
		\item Game iwad path: ``./doom2.wad''
		\item map: ``map01'' (first map created in the iwad file if it's not changed purposefully)
		\item mode: PLAYER
		\item gameVariables: none
		\item customGameArgs: none
		\item available buttons: none
%we should mention somewhere that these values will be set if none is left:
%ATTACK, USE, JUMP, CROUCH, SPEED, MOVE\_RIGHT, MOVE\_LEFT, MOVE\_BACKWARD, MOVE\_FORWARD, TURN\_RIGHT, TURN\_LEFT
		\item rendering: all without crosshair
		\item windowVisible: true 
		\item doomSkill: 3
		\item livingReward/deathPenalty: 0
		\item consoleEnabled: false
		\item startEpisodeTime: 1
		\item episodeTimeout: 0
	\end{itemize}


\vspace{20pt}
\begin{clinee}
~DoomGame();
\end{clinee}

The destructor that safely ends the work of environment and removes the object.


\vspace{20pt}
\begin{clinee}
bool init();
\end{clinee}

Function which initializes enviroment. Configuration cannot be changed after invokation of init(). Dooms instance is created in separate process. Returns true when game was started properly. 


\vspace{20pt}
\begin{clinee}
bool loadConfig(std::string filename);
\end{clinee}

Loads and sets configuration from a configuration file. It's syntax is better described in Section~\ref{sec:configuration_file}. The configuration file can substitute any combination of the following methods call. In case of multiple invokations, they will overwrite selected settings from previous calls. Return true when all configuration was read properly.


\vspace{20pt}
\begin{clinee}
void addAvailableButton(Button button);
\end{clinee}

Makes the specified input type (e.g. TURN\_LEFT, MOVE\_FORWARD ) available (possible) in the AI agent's actions in PLAYER and ASYNC\_PLAYER modes and the human player's actions in SPECTATOR and ASYNC\_SPECTATOR modes. If no buttons are specified (the method is not called) 11 default buttons are added. Their list may be found in constructor description.


\vspace{20pt}
\begin{clinee}
void addAvailableButton(Button button, int maxValue);
\end{clinee}

Makes the specified input type available in actions and sets the maximum allowed value for that input type. 0 as maxValue means no  Its list can be found in Section~\ref{subsec:button}.


\vspace{20pt}
\begin{clinee}
void setButtonMaxValue(Button button, int maxValue);
\end{clinee}

Sets the maximum allowed value for the specified input type. It only applies to actions responsible for rotation and movement, it effectively constraints rotation/moving speed.
0 means no constraint and it is the default behavior. Its list can be found in Section~\ref{subsec:button}.


\vspace{20pt}
\begin{clinee}
void addAvailableGameVariable(GameVariable var);
\end{clinee}

Adds given GameVariable to the list of values returned in getState() (e.g. AMMO1, HEALTH, ATTACK\_READY). It list can be found in Section~\ref{subsec:gamevar}.


\vspace{20pt}
\begin{clinee}
void clearAvailableButtons();
\end{clinee}

Disables all input type in action. It will result in default setting which can be found in constructor description.


\vspace{20pt}
\begin{clinee}
void clearAvailableGameVariables();
\end{clinee}

Clears the list of game variables returned in getState().


\vspace{20pt}
\begin{clinee}
void addCustomGameArg(std::string arg);
\end{clinee}

Adds a custom argument for the ViziaZDoom process.


\vspace{20pt}
\begin{clinee}
void clearCustomGameArgs();
\end{clinee}

Clears all arguments specified by addCustomGameArg().


\vspace{20pt}
\begin{clinee}
void setMode(Mode mode);
\end{clinee}

Sets mode in which the game will be started. Supported formats are defined in Mode enumaration (e.g. PLAYER, SPECTATOR) and can be found in Section~\ref{subsec:mode}..


\vspace{20pt}
\begin{clinee}
void setDoomEnginePath(std::string path);
\end{clinee}

Sets path to Doom engine executable.


\vspace{20pt}
\begin{clinee}
void setDoomGamePath(std::string path);
\end{clinee}

Sets path to the Doom engine based game file.


\vspace{20pt}
\begin{clinee}
void setDoomScenarioPath(std::string path);
\end{clinee}

Sets path to additional file or files (e.g. scenario).


\vspace{20pt}
\begin{clinee}
void setDoomMap(std::string map);
\end{clinee}

Sets map to be used by doom.


\vspace{20pt}
\begin{clinee}      
void setDoomSkill(int skill);
\end{clinee}

Sets Doom game difficulty level (0-4) which is called skill in Doom. Less means easier. It affects ammo, damage and monster aggressiveness.


\vspace{20pt}
\begin{clinee}
void setDoomConfigPath(std::string path);
\end{clinee}

Sets path for Doom configuration file.


\vspace{20pt}
\begin{clinee}    
void setEpisodeStartTime(unsigned int tics);
\end{clinee}

Sets start delay of every episodes in doom tics. Every episode will effectively start (from the user's perspective) after given number of tics.


\vspace{20pt}
\begin{clinee}
void setEpisodeTimeout(unsigned int tics);
\end{clinee}

Sets quantity of tics after which the episode will be finished.


\vspace{20pt}
\begin{clinee}
void setLivingReward(double livingReward);
\end{clinee}

Sets the reward granted for player being alive after each tic.


\vspace{20pt}
\begin{clinee}
void setDeathPenalty(double deathPenalty);
\end{clinee}

Sets penalty for player's death. In case of negative value, player will be rawarded for each decease.


\vspace{20pt}
\begin{clinee}
void setAutoNewEpisode(bool set);
\end{clinee}

Determines if automatic episode restart will be set in case of the end of previous one.


\vspace{20pt}
\begin{clinee}
void setNewEpisodeOnTimeout(bool set);
\end{clinee}

Determines if automatic episode restart will be set in case of the timeout.


\vspace{20pt}
\begin{clinee}
void setNewEpisodeOnPlayerDeath(bool set);
\end{clinee}

Determines if automatic episode restart will be set in case of players death.


\vspace{20pt}
\begin{clinee}
void setNewEpisodeOnMapEnd(bool set);
\end{clinee}

Determines if automatic episode restart is set when player reaches the end of the map.


\vspace{20pt}
\begin{clinee}
void setScreenResolution(ScreenResolution resolution);
\end{clinee}

Sets screen resolution. Supported resolutions are part of ScreenResolution enumeration type and their format is: RES\_xXy (e.g. RES\_320X240, RES\_1920X1080). Buffer as well as content of zdoom's window is affected. Its list can be found in Section~\ref{subsec:resolution}.


\vspace{20pt}
\begin{clinee}
 void setScreenFormat(ScreenFormat format);
\end{clinee}

Sets format of the screen buffer. Supported formats are defined in ScreenFormat enumaration (e.g. CRCGCB, RGB24, GRAY8). Content displayed in zdoom's window what change no matter which format you choose - it only affects the buffer. It list can be found in Section~\ref{subsec:screenformat}.


\vspace{20pt}
\begin{clinee}       
void setRenderHud(bool hud);
void setRenderWeapon(bool weapon);
void setRenderCrosshair(bool crosshair);
void setRenderDecals(bool decals);
void setRenderParticles(bool particles);
\end{clinee}

Methods that determine if some elements (hud, weapon, crosshair, decals, particles) will be displayed.


\vspace{20pt}
\begin{clinee}
void setWindowVisible(bool visibility);
\end{clinee}

Determines if zdoom's window will be visible.
Turning it off will result in:
\begin{itemize}
\item Linux - rendering and any computations connected with the window will be skipped. It results in processing acceleration.
\item Windows - window will be hided. No processing acceleration
\end{itemize}


\vspace{20pt}
\begin{clinee}
void setConsoleEnabled(bool console);
\end{clinee}

Determines if zdoom's and vizia's console output will be displayed (e.g. "You picked up a medpack", "Player killed himself.", "Vizia\_init")


\vspace{20pt}
\subsection{Runtime}\label{subsec:runtime_methods}
The following methods handles gameplay. They directly affect the game and should be used after inicialization. 
Any attempt to invoke them before it will result in a warning/exception depending on severity of consequences. 


\vspace{20pt}
\begin{clinee}
void newEpisode();
\end{clinee}

Initializes new episode. All rewards and map states are restarted.


\vspace{20pt}
\begin{clinee}
	void setAction(std::vector<int> const &actions);
\end{clinee}

Sets the player's behavior in the next tic.
Each vector's value corresponds to button specified with addAvailableButton() function (in invocation order).
In case of possitive value, picked action will be triggered with the specified strength. Descrete actions (e.g. ATTACK) will be performed once.


\vspace{20pt}
\begin{clinee}
	void advanceAction();
\end{clinee}

Method performs a tic using action obtained by setAction(). After function call, action vector is not reseted and will be performed once again if not changed in the next tic.


\vspace{20pt}
\begin{clinee}
	void advanceAction(bool stateUpdate, bool renderOnly, unsigned int tics);
\end{clinee}

Method performs a given number of tics in the row. Descrete actions (e.g. ATTACK) will be only performed in the first tic, analog actions (moving, turning) will be repeated every tic. 
Function also determines if state should be updated. What's more, setting renderOnly option as true will disable buffer update. Hovewer, it will not affect zdoom main window.  


\vspace{20pt}
\begin{clinee}
	double getLastReward();
\end{clinee}

Returns the reward from last advanceAction. If a single action lasted longer then one tick, function will return cumulative reward from all tics.


\vspace{20pt}
\begin{clinee}
	double makeAction(std::vector<int> const &actions);
\end{clinee}

Function combining usibility of setAction(), advanceAction() and getLastReward(). It sets the player's behavior in the next tic, performes one and returns reward.
Each vector's value corresponds to button specified with addAvailableButton() function (in invocation order).
In case of possitive value, picked action will be triggered with the specified strength. Descrete actions (e.g. ATTACK) will be performed once. 


\vspace{20pt}
\begin{clinee}
	double makeAction(std::vector<int> const &actions, unsigned int tics);
\end{clinee}

Function combining usibility of setAction(), advanceAction() and getLastReward(). It sets the player's behavior in the next number of tics given to the function, performes it and returns cumulative reward from all tics. Each vector's value corresponds to button specified with addAvailableButton() function (in invocation order). Descrete actions (e.g. ATTACK) will be only performed in the first tic, analog actions (moving, turning) will be repeated every tic with given strength.
State will be updated after that. Buffer will not be updated.


\vspace{20pt}
\begin{clinee}
	State getState();
\end{clinee}

Returns struct State with the current game state. More detailed description of the struct can be found in Section~\ref{sec:structs}.


\vspace{20pt}
\begin{clinee}
	std::vector<int> getLastAction();
\end{clinee}

Returns a vector with the last action performed. Each vector's value corresponds to button specified with addAvailableButton() function (in invocation order). Most usefull in SPECTATOR mode.


\vspace{20pt}
\begin{clinee}
	uint8_t * const getGameScreen();
\end{clinee}

Returns the screen buffer. Values depend on the settings set befor inicialization. The same value may be found in State structure. Its length is returned in getScreenPitch() function.


\vspace{20pt}
\begin{clinee}
	int getGameVariable(GameVariable var);
\end{clinee}

Returns value of the specified game variable (AMMO1, HEALTH etc.). It does not need to be a value returned in State.
It could be used for e.g. shaping. Returns 0 in case of not finding given GameVariable.


\vspace{20pt}
\begin{clinee}
	double getSummaryReward();
\end{clinee}

Returns sum of all rewards gathered in the current episode.


\vspace{20pt}
\begin{clinee}
	bool isNewEpisode();
\end{clinee}

Checks if the current episode is in the initial state. Returns true if no tic was performed.


\vspace{20pt}
\begin{clinee}
	bool isEpisodeFinished();
\end{clinee}

Checks if the current episode is in the terminal state. Returns true if the episode has ended. No makeAction/advanceAction functions should be called after this point.


\vspace{20pt}
\begin{clinee}
	void setSeed(unsigned int seed);
\end{clinee}

Sets the seed of the randomizing engine. Using the same seed and actions in another episode will affect in reproducing the gameplay.


\vspace{20pt}
\begin{clinee}
	void close();
\end{clinee}

Closes zdoom engine and corresponding processes. Metod frees used resources (memory allocations e.t.c). It is automatically invoked by destructor - should be used only when closing zdoom engine in the middle of processing is needed.


\vspace{20pt}
\begin{clinee}
	bool isRunning();
\end{clinee}

Checks if the current zdoom process is running.


\vspace{20pt}
\begin{clinee}
	void sendGameCommand(std::string cmd);
\end{clinee}

Sends a given command to zdoom console. Can be used for cheats, multiplayer e.t.c.


\vspace{20pt}
\subsection{Universal}


Api provides a number of getters associated with the above-mentioned functions and a set of additional methods to help converts game units.
  

\vspace{20pt}
\begin{clinee}
int getAvailableButtonsSize();
int getAvailableGameVariablesSize();
Mode getMode();
double getLivingReward();
double getDeathPenalty();
unsigned int getEpisodeStartTime();
unsigned int getEpisodeTimeout();
unsigned int getEpisodeTime();
int getScreenWidth();
int getScreenHeight();
int getScreenChannels();
size_t getScreenPitch();
size_t getScreenSize();
ScreenFormat getScreenFormat();
unsigned int getSeed();
int getButtonMaxValue(Button button);
\end{clinee}


\paragraph {Metods} Metods outsite the DoomClass:


\begin{clinee}
unsigned int DoomTics2Ms(unsigned int tics);
\end{clinee}

Function calculating number of milliseconds during given tics (assuming 35 tics per second - designed Doom ticrate).


\vspace{20pt}
\begin{clinee}
unsigned int Ms2DoomTics(unsigned int ms);
\end{clinee}

Function calculating how many tics will be made during given number of milliseconds (assuming 35 ticks per second - designed Doom ticrate).


\vspace{20pt}
\begin{clinee}
double DoomFixedToDouble(int doomFixed);
\end{clinee}

Function calculating values of user's DoomFixed ACS variables (USER1, USER2 etc.) to double.


\vspace{20pt}
\section{Structures and Enumerations} \label{sec:structs}
\subsection{State}


Structure created to store all the information needed by inteligent agent to process the image.  
It is composed of three public fields:

\vspace{20pt}	
\begin{clinee}
	struct State {
	    unsigned int number; 
	    std::vector<int> gameVariables;
	    uint8_t * imageBuffer;
	};
\end{clinee}
\paragraph{number} States number in the current episode.
\paragraph{gameVariables} Vector storing user-defined during the configuration values drawn from the game such as AMMO or HEALTH. 
\paragraph{imageBuffer} Pointer to the screen buffer, containing the image information.

\subsection{Mode}\label{subsec:mode}
ScreenResolution enum has been designed to represent available game modes.


\vspace{20pt}
\textbf{Modes:}
\begin{itemize}
\item PLAYER \\
Setting where AI has full control over the game. It makes decision which action to perform and decides when the engine should make another processing loop.
\item SPECTATOR \\
Setting where human has control over the game and Inteligent Agent learns from his gameplay. AI only decides when the engine should make another loop to be able to process all the image data. Human makes decision which action should be performed and have to wait until AI is ready. 
\item ASYNC\_PLAYER \\ 
Setting where AI has control over the game. It makes decision which action to perform but AI can not control engines processing loop. If Inteligent Agent will not manage to perform any action and will not end image processing, next tic will be made with previous operations.
//TODO ILE CZASU?!
\item ASYNC\_SPECTATOR \\
Setting where human has control over the game and Inteligent Agent learns from his gameplay. AI has access to current visual information, a last action taken along with an award and the rest of the variables on the basis of which should draw conclusions. Human plays with a standard number of fps and does not need to wait for the completion of AIs processing.
\end{itemize}

\subsection{ScreenFormat}\label{subsec:screenformat}
ScreenResolution enum has been designed to represent the possible screen formats in witch game image will be returned. 


\vspace{20pt}
\textbf{ScreenFormats:}
\begin{itemize}
 \item CRCGCB 
 \item CRCGCBDB
 \item RGB24
 \item RGBA32
 \item ARGB32
 \item CBCGCR
 \item CBCGCRDB
 \item BGR24
 \item BGRA32
 \item ABGR32
 \item GRAY8
 \item DEPTH_BUFFER8
 \item DOOM\_256\_COLORS
\end{itemize}
\subsection{ScreenResolution} \label{subsec:screenresolution}
ScreenResolution enum has been designed to represent the possible screen resolutions in the game. Their full list can be found in the apendix.


\vspace{20pt}
\textbf{ScreenResolution examples:}
\begin{itemize}
\item RES\_40X30
\item RES\_160X120	
\item RES\_480X270	
\item RES\_480X360	
\item RES\_800X600
\item RES\_5120X2880
\end{itemize}

\subsection{GameVariable} \label{subsec:gamevar}
GameVariable enum has been designed to represent the possible parameters in the game that can be downloaded and used to determine the next behavior of artificial intelligence. Its value after their inicialization can be found in the \textit{gameVariables} vector returned in game state. Their full list can be found in the apendix.


\vspace{20pt}
\textbf{ScreenResolution examples:}
\begin{itemize}
\item KILLCOUNT\\
Variables which represent number of kills performed by the player in the episode.
\item ITEMCOUNT\\
Variables which represent number of items taken in the episode.
\item HEALTH\\
Variable which represent players condition.
\item AMMO1
\item AMMO2\\
Variables which represent available ammunition to each weapon.
\item WEAPON1
\item WEAPON2 \\
Variables which represent presence of the weapons.
\item USER1 \\
\item USER2 \\
User-defined global variables. More in Section~\ref{subsec:global_variable}.
\end{itemize}

\subsection{Button} \label{subsec:button}
Button enum has been designed to represent the possible prime factors that make up a single action. Some of them can be further configured with a value indicating the angle of rotation or shift done in a single call. If not set, default force is used. Setting this additional value to the simple button without this option will not affect its call. If action lasting longer than 1 tic is performed, buttons correlated with move will be made continuously when simple actions will be made once in the first tic. Their full list can be found in the apendix.


\vspace{20pt}
\textbf{Simple buttons examples:}
\begin{itemize} 
\item ATTACK
\item USE
\item JUMP
\item CROUCH
\item TURN180
\end{itemize}


\vspace{20pt}
\textbf{Move buttons examples:}
\begin{itemize} 
\item MOVE\_RIGHT
\item MOVE\_BACKWARD
\end{itemize} 


\vspace{20pt}
\textbf{Move/rotation buttons examples:}
\begin{itemize} 
 \item LOOK\_UP\_DOWN\_DELTA
 \item TURN\_LEFT\_RIGHT\_DELTA
 \item MOVE\_FORWARD\_BACKWARD\_DELTA
 \item MOVE\_LEFT\_RIGHT\_DELTA
 \item MOVE\_UP\_DOWN\_DELTA
\end{itemize}

\section{Configuration file}\label{sec:configuration_file}


Configuration file stores group of parameters and initial settings for the future use. It can be loaded into the game before inicialization. Settings can be overwritten after that action, giving the possibility of changing sigle parameter without interference in the file itself. There should be met certain requirements as to its content and name to make it load successfully.

Name of the configuration file should be with .properties suffix.

Content of the file should be composed of keywords identifying the setting and the value assigned to it separated with '='. Keyword is constructed similarly to the setting name, for example: episodeStartTime, windowVisible. However, two of them differ: availablebuttons, availablegamevariables.
Keyword can be written in both underscore and camel notation (case-insensitive). 


Value should be placed after '=' sign. File paths should not be placed between "" marks like the rest of the string values.
\begin{pblock}
...
#Values
living_reward = -1
render_crosshair = false
#Path
doom_iwad_path = ../../scenarios/doom2.wad
doom_file_path = ../../scenarios/basic.wad
#Normal String
doom_map = "map01"
...
\end{pblock}
Enum values should be passed using their name.
\begin{pblock}
...
#Enums
screen_format = CRCGCB
mode = PLAYER
...
\end{pblock}
Each setting should be separated from each other by a sign of the new line. In order to improve readability, it's possible to add a comment line by adding a '\#' sign at the beginning of the new line.

An exceptionally behave here availablebuttons and availablegamevariables functions because instead of individual variables, take as an argument the list of values in '\{\}'. The individual components should be separated from each other by a newline.
\begin{pblock}
...
# Available buttons
available_buttons = 
	{ 
		MOVE_LEFT 
		MOVE_RIGHT 
		ATTACK 
	}
# Game variables that will be in the state
available_game_variables = { AMMO2}
...
\end{pblock}

\section{Wrappers}
\subsection{Python}

Python functions and metods are very similar to the c++ ones. Howewer, because of the language differences, some of the values may vary. All differences are listed below.

\paragraph {Naming}
Naming convention used in python binding is underscore. The only exception is the constructor which is named in the same way like in c++.

\begin{cblock}
c++: DoomFixedToDouble(int doomFixed)
python: doom_fixed_to_double(int doomFixed)
\end{cblock}


\paragraph {Structures}
 State is changed structuraly: bufer is a numpy array and game variables are contained in a Python list. Whats more, getState() copies the buffer and gameVariables what doesn't happen in cpp. 
\paragraph {Enumerations}
Python equivalent of enums were created with the same names.
\begin{cblock}
game.add_available_button(Button.TURN_LEFT_RIGHT_DELTA)
game.add_available_button(Button.MOVE_LEFT)
\end{cblock}
\paragraph {Types}
Due to the languages differences, some types have been modified.
\begin{itemize} 
\item Vectors in all functions were changed to python lists of compatible type.

\item  uint8\_t, unsigned int, size\_t were changed to int
\end{itemize}



\subsection{Java}
Java, like python, is a bit different then c++. All differences and the most important principles of using are listed below.

\paragraph {Naming}
 Naming convention is camelcase, the same like in c++. 
\begin{cblock}
c++: DoomFixedToDouble(int doomFixed)
java: DoomFixedToDouble(int doomFixed)
\end{cblock}
\paragraph {Structures}
State is changed structuraly: bufer and game variables are int tables (int[]). Whats more, getState() copies the buffer and gameVariables what doesn't happen in cpp. 
\paragraph {Enumerations}
Java equivalent of enums were created with the same names.
\begin{cblock}
dg.addAvailableButton(Button.ATTACK);
dg.addAvailableButton(Button.MOVE_LEFT);
\end{cblock}
\paragraph {Types}
Due to the languages differences, some types have been modified.
\begin{itemize}
\item Vectors in all functions were changed to java tables of compatible type (vector<int> = int[]).
\item uint8\_t, unsigned int, size\_t were changed to int
\end{itemize}
\section{Extended Examples}
\subsection{Spectator mode}
Spectator mode is designed to enable artificial intelligence to learn directly from humans game.
Python listing presented below demonstrates the use of this option in which a human takes control over the game and Intelligent Agent looks at and analyzes the movements. In this synchronous mode, Artificial Intelligence has power over the engine and decides when human can make the next move. 


After the initial configuration in which available actions and collected variables from the game are set, the script runs sequence of 10 episodes. During their run, the image is downloaded and the human gets the opportunity to perform a single action which are then read and stored by the script. After this process, processing of AI follows. Downloaded data is printed at the end of the loop, such as the values of game variables set in the game and operations taken with associated reward. What's more, before the end of each episode, a summary is displayed followed by 2 second delay.

\begin{pblock}
from __future__ import print_function
from vizia import *
from time import sleep

game = DoomGame()
game.load_config("config_deathmatch.properties")
game.set_screen_resolution(ScreenResolution.RES_640X480)
game.add_available_button(Button.TURN_LEFT_RIGHT_DELTA)
game.set_window_visible(True)
game.set_mode(Mode.SPECTATOR)
game.init()

episodes = 10
print("")
for i in range(episodes):
	print("Episode #" +str(i+1))
	
	game.new_episode()
	while not game.is_episode_finished():
		
		s = game.get_state()
		img = s.image_buffer
		misc = s.game_variables

		game.advance_action()
		a = game.get_last_action()
		r = game.get_last_reward()
		...		
		#IA processing
		...
		print("state #"+str(s.number))
		print("game variables: ", misc)
		print("action:", a)
		print("reward:",r)
		print("=====================")

	
	print("episode finished!")
	print("summary reward:", game.get_summary_reward())
	print("************************")
	sleep(2.0)

game.close()
\end{pblock}

\subsection {Seed}
Seed setting was created to enable running deterministic episodes. Thanks to that, if agent behaves in the same way, each episode can be recreated.

The following listing demonstrates usiage of a seed in the script. Once it is set along with other parameters in the configuration phase, list of all possible actions is made. In each episode, state of the game is processed and action is made based on AI decision. In that point, operation taken in the game should be saved to make it possible to recreate the episode in the future. Downloaded data is printed at the end of the loop, such as game state number, the values of variables set in the game and reward for last action made. After each episode, quick summary is displayed. To recreate one of the episodes, the same seed should be set and the same actions in wright time should be taken.

\begin{pblock}
from __future__ import print_function
from vizia import *
from random import choice
import itertools as it
from time import sleep

game = DoomGame()

game.load_config("config_basic.properties")
game.set_screen_resolution(ScreenResolution.RES_640X480)

seed = 1234
# Sets the seed.
game.set_seed(seed)

game.init()

# Creates all possible actions depending on how many buttons there are.
actions_num = game.get_available_buttons_size()
actions = []
for perm in it.product([False, True], repeat=actions_num):
    actions.append(list(perm))

episodes = 10
sleep_time = 0.028

for i in range(episodes):
	print("Episode #" + str(i+1))
	game.new_episode()

	while not game.is_episode_finished():
		# Gets the state and possibly do something with it
		s = game.get_state()
		img = s.image_buffer
		misc = s.game_variables

		...
		# IA processing
		...		
		
		# Check which action you chose and save it!
		r = game.make_action(choice(actions))
		
		
		print("State #" + str(s.number))
		print("Game Variables:", misc)
		print("Last Reward:", r)
		print("=====================")

	print("Episode finished!")
	print("Summary reward:", game.get_summary_reward())
	print("************************")


game.close()
\end{pblock}

\subsection {Multiplayer}
Multiplayer mode was configured to enable creating deathmatch between human and AI (or only AI). To create such game, at least two scripts should be prepered.

\paragraph{Host player}
To create the game, host player script should be implemented with all appropriate configuration. After setting basic options like resolution and gamemode (asynchronous should be used), some addition game arguments should be passed using addCustomGameArg() function. They define max number of players, variant of the game and used map. In the following script, Spectator mode is picked and AI is only processing image data and updating game state using advance\_action(). At the end of each loop, log is displayed on the console window.

\begin{pblock}
from __future__ import print_function
from vizia import *
from random import choice
from time import sleep
from time import time

game = DoomGame()
game.load_config("config_multi.properties")
game.add_custom_game_arg("-host")
game.add_custom_game_arg("2")
game.add_custom_game_arg("-deathmatch")
game.add_custom_game_arg("-warp")
game.add_custom_game_arg("-01")
game.set_mode(Mode.ASYNC_SPECTATOR)
game.init()

	
episodes = 1

for i in range(episodes):
	
	while not game.is_episode_finished():	
		s = game.get_state()
		img = s.image_buffer
		misc = s.game_variables

		game.advance_action()
		a = game.get_last_action()
		r = game.get_last_reward()
			
		print("state #"+str(s.number))
		print("game variables: ", misc)
		print("action:", a)
		print("reward:", r)
		print("=====================")
	
print("episode finished!")
print("summary reward:", game.get_summary_reward())
print("************************")

game.close()
\end{pblock}


To join an existing game, some additional configuration using game arguments should be made. Host player should be pointed by passing his ip number. In followinig egzample, AI can make 3 types of actions: shoot, move left or move right. It is picked after image processing. At the end of each loop, log is displayed on the console window.

\begin{pblock}
from __future__ import print_function
from vizia import *
from random import choice
from time import sleep
from time import time



game = DoomGame()
game.load_config("config_multi.properties")

game.add_available_button(Button.ATTACK)
game.add_available_button(Button.MOVE_LEFT)
game.add_available_button(Button.MOVE_RIGHT)
game.set_mode(Mode.ASYNC_PLAYER)
game.add_custom_game_arg("-join")
game.add_custom_game_arg("127.0.0.1")
game.set_window_visible(False)
game.init()


actions = [[1,0,0],[0,1,0],[0,0,1]]

episodes = 1

for i in range(episodes):
	
	while not game.is_episode_finished():	
		s = game.get_state()
		img = s.image_buffer
		misc = s.game_variables

		game.make_action(choice(actions))
		a = game.get_last_action()
		r = game.get_last_reward()
			
		print("state #"+str(s.number))
		print("game variables: ", misc)
		print("action:", a)
		print("reward:", r)
		print("=====================")
	
	print("episode finished!")
	print("summary reward:", game.get_summary_reward())
	print("************************")

game.close()
\end{pblock}

