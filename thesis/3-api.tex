
\chapter{Application Programming Interface}
\section{Methods}
\subsection{Configuration}
Methods described below are setting the main parameters of the environment, such as resolution of the generated image or Intelligent Agent's available actions. They should be invoked before the init() method. Any attempt to invoke them after initialization will result in a warning/exception depending on severity of consequences. 
\vspace{20pt}

\begin{clinee}
DoomGame();
\end{clinee}

Constructor that creates an instance of the game. Zdoom is not ready for action after the constructor, it needs further initialization. Object is inicialized with the following values:
	\begin{itemize}
\item Resolution: 640x480
\item Game path: ./viziazdoom
\item Game iwad path: "./doom2.wad"
\item Map: map01 (first map created in the iwad file if it's not changed purposefully)
\item Particles, hud, weapon, crosshair, decals are displayed 
\item Window is displayed 
	\end{itemize}


\vspace{20pt}
\begin{clinee}
~DoomGame();
\end{clinee}

The destructor that safely ends the work of environment and removes the object.


\vspace{20pt}
\begin{clinee}
bool init();
\end{clinee}

Function which initializes enviroment. Configuration cannot be changed after invokation of init(). Dooms instance is created in separate process. Returns true when game was started properly. 


\vspace{20pt}
\begin{clinee}
bool loadConfig(std::string filename);
\end{clinee}

Loads and sets configuration from a configuration file. It's syntax is better described in Section~\ref{sec:configuration_file}. The configuration file can substitute any combination of the following methods call. In case of multiple invokations, they will overwrite selected settings from previous calls. Return true when all configuration was read properly.


\vspace{20pt}
\begin{clinee}
void addAvailableButton(Button button);
\end{clinee}

Adds support for the specified actions (e.g. TURN\_LEFT, MOVE\_FORWARD ). If no buttons are specified (the method is not called) 11 default buttons are added. Their list may be found in constructor description.


\vspace{20pt}
\begin{clinee}
void addAvailableButton(Button button, int maxValue);
\end{clinee}

Adds support for the specified actions responsible for rotation and sets the amount of movement done. It only applies to "buttons" responsible for rotation. it effectively constraints rotation speed. %TODO CO TO ROBI?!


\vspace{20pt}
\begin{clinee}
void setButtonMaxValue(Button button, int maxValue);
\end{clinee}

Sets the button's max value. It only applies to "buttons" responsible fors rotation and moving(with specified speed), it effectively constraints rotation/moving speed.
0 means no constraint and it's the default behavior TODO %TODO CO TO ROBI?!


\vspace{20pt}
\begin{clinee}
void addAvailableGameVariable(GameVariable var);
\end{clinee}

Adds given GameVariable to the list of values returned in getState() (e.g. AMMO1, HEALTH, ATTACK\_READY).


\vspace{20pt}
\begin{clinee}
void clearAvailableButtons();
\end{clinee}

Disables support for any specified buttons. It will result in default setting which can be found in constructor description.


\vspace{20pt}
\begin{clinee}
void clearAvailableGameVariables();
\end{clinee}

Clears the list of game variables returned in getState().


\vspace{20pt}
\begin{clinee}
void addCustomGameArg(std::string arg);
\end{clinee}

Adds a custom argument for the zdoom process. %TODO OPIS


\vspace{20pt}
\begin{clinee}
void clearCustomGameArgs();
\end{clinee}

Clears all arguments specified by addCustomGameArg().


\vspace{20pt}
\begin{clinee}
void setMode(Mode mode);
\end{clinee}

Sets mode in which the game will be started. Supported formats are defined in Mode enumaration (e.g. PLAYER, SPECTATOR).


\vspace{20pt}
\begin{clinee}
void setDoomGamePath(std::string path);
\end{clinee}

Sets path to zdoom executable.


\vspace{20pt}
\begin{clinee}
void setDoomIwadPath(std::string path);
\end{clinee}

Sets path to the game iwad file.


\vspace{20pt}
\begin{clinee}
void setDoomFilePath(std::string path);
\end{clinee}

Sets path to additional iwad file (e.g. scenario).


\vspace{20pt}
\begin{clinee}
void setDoomMap(std::string map);
\end{clinee}

Sets map to be used by doom.


\vspace{20pt}
\begin{clinee}      
void setDoomSkill(int skill);
\end{clinee}

Sets doom game difficulty level (0-5) which is called skill in doom. Less means easier. It affects ammo, life amount and monster aggressiveness. %TODO co tutaj? 


\vspace{20pt}
\begin{clinee}
void setDoomConfigPath(std::string path);
\end{clinee}

Sets path for doom configuration file.


\vspace{20pt}
\begin{clinee}    
void setEpisodeStartTime(unsigned int tics);
\end{clinee}

Sets start delay of every episodes in doom tics. Every episode will effectively start (from the user's perspective) after given number of tics.


\vspace{20pt}
\begin{clinee}
void setEpisodeTimeout(unsigned int tics);
\end{clinee}

Sets quantity of tics after which the episode will be finished.


\vspace{20pt}
\begin{clinee}
void setLivingReward(double livingReward);
\end{clinee}

Sets the reward granted for player being alive after each tic.


\vspace{20pt}
\begin{clinee}
void setDeathPenalty(double deathPenalty);
\end{clinee}

Sets penalty for player's death. In case of negative value, player will be rawarded for each decease.


\vspace{20pt}
\begin{clinee}
void setAutoNewEpisode(bool set);
\end{clinee}

Determines if automatic episode restart will be set in case of the end of previous one.


\vspace{20pt}
\begin{clinee}
void setNewEpisodeOnTimeout(bool set);
\end{clinee}

Determines if automatic episode restart will be set in case of the timeout.


\vspace{20pt}
\begin{clinee}
void setNewEpisodeOnPlayerDeath(bool set);
\end{clinee}

Determines if automatic episode restart will be set in case of players death.


\vspace{20pt}
\begin{clinee}
void setNewEpisodeOnMapEnd(bool set);
\end{clinee}

Determines if automatic episode restart is set when player reaches the end of the map.


\vspace{20pt}
\begin{clinee}
void setScreenResolution(ScreenResolution resolution);
\end{clinee}

Sets screen resolution. Supported resolutions are part of ScreenResolution Enumeration type and their format is: RES\_xXy (e.g. RES\_320X240, RES\_1920X1080). Buffer as well as content of zdoom's window is affected.


\vspace{20pt}
\begin{clinee}
 void setScreenFormat(ScreenFormat format);
\end{clinee}

Sets format of the screen buffer. Supported formats are defined in ScreenFormat enumaration (e.g. CRCGCB, RGB24, GRAY8). Content displayed in zdoom's window what change no matter which format you choose - it only affects the buffer.


\vspace{20pt}
\begin{clinee}       
void setRenderHud(bool hud);
void setRenderWeapon(bool weapon);
void setRenderCrosshair(bool crosshair);
void setRenderDecals(bool decals);
void setRenderParticles(bool particles);
\end{clinee}

Methods that determine if some elements (hud, weapon, crosshair, decals, particles) will be displayed.


\vspace{20pt}
\begin{clinee}
void setWindowVisible(bool visibility);
\end{clinee}

Determines if zdoom's window will be visible.
Turning it off will result in:
\begin{itemize}
\item Linux - rendering and any computations connected with the window will be skipped. It results in processing acceleration
\item Windows - window will be hided. No processing acceleration
\end{itemize}


\vspace{20pt}
\begin{clinee}
void setConsoleEnabled(bool console);
\end{clinee}

Determines if zdoom's and vizia's console output will be displayed (e.g. "You picked up a medpack", "Player killed himself.", "Vizia\_init ....")


\vspace{20pt}
\subsection{Runtime}
The following methods handles gameplay. They directly affect the game and should be used after inicialization. 
Any attempt to invoke them before it will result in a warning/exception depending on severity of consequences. 


\vspace{20pt}
\begin{clinee}
void newEpisode();
\end{clinee}

Initializes new episode. All rewards, map state etc are restarted.


\vspace{20pt}
\begin{clinee}
	void setAction(std::vector<int> &actions);
\end{clinee}

Sets the player's behavior in the next tic.
Each vector's value corresponds to button specified with addAvailableButton() function (in invocation order).
In case of possitive value, picked action will be triggered with the specified strength. Descrete actions (e.g. ATTACK) will be performed once.


\vspace{20pt}
\begin{clinee}
	void advanceAction();
\end{clinee}

Method performs a tic using action obtained by setAction(). After function call, action vector is not reseted and will be performed once again if not changed.


\vspace{20pt}
\begin{clinee}
	void advanceAction(bool stateUpdate, bool renderOnly, unsigned int tics);
\end{clinee}

Method performs a given number of tic in the row. Descrete actions (e.g. ATTACK) will be only performed in the first tic, analog actions (moving, turning) will be repeated every tic. 
Function also determines if state should be updated. What's more, setting renderOnly option will disable buffer update. Hovewer, it will not affect zdoom main window.  


\vspace{20pt}
\begin{clinee}
	double getLastReward();
\end{clinee}

Returns the reward from last advanceAction. If a single action lasted longer then one tick, function it will return cumulative reward from all tics.


\vspace{20pt}
///////////////////////////DALEJ TYLKO NA BRUDNO///////////////////////////
\begin{clinee}
	double makeAction(std::vector<int> &actions);
\end{clinee}
\begin{clinee}
	double makeAction(std::vector<int> &actions, unsigned int tics);
\end{clinee}
Convinience methods which wrap setAction, advanceAction and getLastReward.
It sets the action, performs it and returns the reward. (set actions, advancedaction(t,t,tics), getLastReward)

\begin{clinee}
	State getState();
\end{clinee}
Returns struct State with the current state. More detailed description is in the last section of the sketch.
\begin{clinee}
	std::vector<int> getLastAction();
\end{clinee}
Returns a vector (list in python) with the last action performed. Format is the same as for setAction.
Most usefull in SPECTATOR mode
\begin{clinee}
	uint8_t * const getGameScreen();
\end{clinee}
Returns the screen buffer. //TODO jak długi, co w pythonie i javie
\begin{clinee}
	int getGameVariable(GameVariable var);
\end{clinee}
Returns value of the specified game variable (AMMO1, HEALTH etc.). It need not be returned by getState.
It could be used for e.g. shaping. It can return 0 if GameVariable wasnt found;
\begin{clinee}
	double getSummaryReward();
\end{clinee}
Returns all rewards gathered in the current episode.
\begin{clinee}
	bool isNewEpisode();
\end{clinee}
Returns true if the episode is in the initial state (no tic was performed).
\begin{clinee}
	bool isEpisodeFinished();
\end{clinee}
Returns true if the current episode is in the terminal state.
Calling makeAction/advance when episode is finished will fry the motherboard. xD
\begin{clinee}
	void setSeed(unsigned int seed);
\end{clinee}
Sets the seed of the randomizing engine. Next time, using the same sid and actions, game can be repeted.
\begin{clinee}
	void close();
\end{clinee}
Closes zdoom engine and tidies up. It is invoked by destructor so it's not that useful unless you won't to close doom in the middle of processing.
\begin{clinee}
	bool isRunning();
\end{clinee}
Returns true if zdoom process is up and running (after init).
\begin{clinee}
	void sendGameCommand(std::string cmd);
\end{clinee}
Sends a command to doom console (cheats, multiplayer? etc.)
\subsection{QUERY INTERFACE}
These are getters which usually are self-explanatory and are tightly bound with settings which are described above.
  \begin{clinee}
int getAvailableButtonsSize();
int getAvailableGameVariablesSize();
Mode getMode();
double getLivingReward();
double getDeathPenalty();
unsigned int getEpisodeStartTime();
unsigned int getEpisodeTimeout();
unsigned int getEpisodeTime();
int getScreenWidth();
int getScreenHeight();
int getScreenChannels();
size_t getScreenPitch();
size_t getScreenSize();
ScreenFormat getScreenFormat();
unsigned int getSeed();
int getButtonMaxValue(Button button);
\end{clinee}
Metods outsite the DoomClass:
\begin{clinee}
unsigned int DoomTics2Ms(unsigned int tics);
\end{clinee}
Function calculating number of ms during given tics.
\begin{clinee}
unsigned int Ms2DoomTics(unsigned int ms);
\end{clinee}
Function calculating how many tics will be made during given ms.
\begin{clinee}
double DoomFixedToDouble(int doomFixed);
\end{clinee}

\section{Structures and Enumerations}
\subsection{State}	
\begin{clinee}
	struct State {
	    unsigned int number; 
	    std::vector<int> gameVariables;
	    uint8_t * imageBuffer;
	};
	\end{clinee}
Structure with gives the programist information about current state in game.\\
number - Number of the state in the current episode.\\
gameVariables - Vector of gameVariables, empty if there are none or it's a terminal state\\
imageBuffer - pointer to the screen buffer, null if it's a terminal state (length ?????)
\begin{itemize}
\item struct state
\item enumeration types . . .or maybe move it to the apendinx?
\end{itemize}
\subsection{Mode}
Used to set who is playing the game.
\begin{clinee}
    enum Mode {
        PLAYER,
        SPECTATOR,
        ASYNC_PLAYER,
        ASYNC_SPECTATOR,
    };
\end{clinee}
\subsection{ScreenFormat}
\begin{clinee}
CRCGCB = 0,
        CRCGCBZB = 1,
        RGB24 = 2,
        RGBA32 = 3,
        ARGB32 = 4,
        CBCGCR = 5,
        CBCGCRZB = 6,
        BGR24 = 7,
        BGRA32 = 8,
        ABGR32 = 9,
        GRAY8 = 10,
        ZBUFFER8 = 11,
        DOOM_256_COLORS = 12,
\end{clinee}
\subsection{ScreenResolution}
\begin{clinee}
RES_40X30,
        RES_60X45,
        RES_80X50,
        RES_80X60,
        RES_100X75,
        RES_120X75,
        RES_120X90,
        RES_160X100,
        RES_160X120,
        RES_200X120,
        RES_200X150,
        RES_240X135,
        RES_240X150,
        RES_240X180,
        RES_256X144,
        RES_256X160,
        RES_256X192,
        RES_320X200,
        RES_320X240,
        RES_400X225,	// 16:9
        RES_400X300,
        RES_480X270,	// 16:9
        RES_480X360,
        RES_512X288,	// 16:9
        RES_512X384,
        RES_640X360,	// 16:9
        RES_640X400,
        RES_640X480,
        RES_720X480,	// 16:10
        RES_720X540,
        RES_800X450,	// 16:9
        RES_800X480,
        RES_800X500,	// 16:10
        RES_800X600,
        RES_848X480,	// 16:9
        RES_960X600,	// 16:10
        RES_960X720,
        RES_1024X576,	// 16:9
        RES_1024X600,	// 17:10
        RES_1024X640,	// 16:10
        RES_1024X768,
        RES_1088X612,	// 16:9
        RES_1152X648,	// 16:9
        RES_1152X720,	// 16:10
        RES_1152X864,
        RES_1280X720,	// 16:9
        RES_1280X854,
        RES_1280X800,	// 16:10
        RES_1280X960,
        RES_1280X1024,	// 5:4
        RES_1360X768,	// 16:9
        RES_1366X768,
        RES_1400X787,	// 16:9
        RES_1400X875,	// 16:10
        RES_1400X1050,
        RES_1440X900,
        RES_1440X960,
        RES_1440X1080,
        RES_1600X900,	// 16:9
        RES_1600X1000,	// 16:10
        RES_1600X1200,
        RES_1680X1050,	// 16:10
        RES_1920X1080,
        RES_1920X1200,
        RES_2048X1536,
        RES_2560X1440,
        RES_2560X1600,
        RES_2560X2048,
        RES_2880X1800,
        RES_3200X1800,
        RES_3840X2160,
        RES_3840X2400,
        RES_4096X2160,
        RES_5120X2880,
\end{clinee}
\subsection{GameVariable}
\begin{clinee}
KILLCOUNT,
        ITEMCOUNT,
        SECRETCOUNT,
        FRAGCOUNT,
        HEALTH,
        ARMOR,
        DEAD,
        ON_GROUND,
        ATTACK_READY,
        ALTATTACK_READY,
        SELECTED_WEAPON,
        SELECTED_WEAPON_AMMO,
        AMMO0,
        AMMO1,
        AMMO2,
        AMMO3,
        AMMO4,
        AMMO5,
        AMMO6,
        AMMO7,
        AMMO8,
        AMMO9,
        WEAPON0,
        WEAPON1,
        WEAPON2,
        WEAPON3,
        WEAPON4,
        WEAPON5,
        WEAPON6,
        WEAPON7,
        WEAPON8,
        WEAPON9,
        USER1,
        USER2,
        USER3,
        USER4,
        USER5,
        USER6,
        USER7,
        USER8,
        USER9,
        USER10,
        USER11,
        USER12,
        USER13,
        USER14,
        USER15,
        USER16,
        USER17,
        USER18,
        USER19,
        USER20,
        USER21,
        USER22,
        USER23,
        USER24,
        USER25,
        USER26,
        USER27,
        USER28,
        USER29,
        USER30,
\end{clinee}
\subsection{Button}
\begin{clinee}
ATTACK = 0,
        USE = 1,
        JUMP = 2,
        CROUCH = 3,
        TURN180 = 4,
        ALTATTACK = 5,
        RELOAD = 6,
        ZOOM = 7,

        SPEED = 8,
        STRAFE = 9,

        MOVE_RIGHT = 10,
        MOVE_LEFT = 11,
        MOVE_BACKWARD = 12,
        MOVE_FORWARD = 13,
        TURN_RIGHT = 14,
        TURN_LEFT = 15,
        LOOK_UP = 16,
        LOOK_DOWN = 17,
        MOVE_UP = 18,
        MOVE_DOWN = 19,
        LAND = 20,
        //SHOWSCORES 20

        SELECT_WEAPON1 = 21,
        SELECT_WEAPON2 = 22,
        SELECT_WEAPON3 = 23,
        SELECT_WEAPON4 = 24,
        SELECT_WEAPON5 = 25,
        SELECT_WEAPON6 = 26,
        SELECT_WEAPON7 = 27,
        SELECT_WEAPON8 = 28,
        SELECT_WEAPON9 = 29,
        SELECT_WEAPON0 = 30,

        SELECT_NEXT_WEAPON = 31,
        SELECT_PREV_WEAPON = 32,
        DROP_SELECTED_WEAPON = 33,

        ACTIVATE_SELECTED_ITEM = 34,
        SELECT_NEXT_ITEM = 35,
        SELECT_PREV_ITEM = 36,
        DROP_SELECTED_ITEM = 37,

        LOOK_UP_DOWN_DELTA = 38,
        TURN_LEFT_RIGHT_DELTA = 39,
        MOVE_FORWARD_BACKWARD_DELTA = 40,
        MOVE_LEFT_RIGHT_DELTA = 41,
        MOVE_UP_DOWN_DELTA = 42,
\end{clinee}
\section{Configuration file}\label{sec:configuration_file}
\begin{itemize}
\item structure
\end{itemize}

\section{Wrappers}
\subsection{Python}
Python functions and metods are very similar to the c++ ones. Howewer, because of the language differences, some of the values may vary.
\begin{itemize}
\item Naming convention is underscore not camelcase for all methods except for the constructor
\begin{clinee}
c++: DoomFixedToDouble(int doomFixed)
python: doom\_fixed\_to\_double(int doomFixed)
\end{clinee}
\item State is changed structuraly: bufer is a numpy array and game variables are a Python list. Whats more, getState copies the buffer and gameVariables, it doesn't happen in cpp. 
\item vectors in all functions  are changed to python lists.
\item Enumerations are created the same like in c++
\item uint8\_t, unsigned int, size\_t are changed to int
\end{itemize}
\subsection{Java}
\begin{itemize}
\item Naming convention is camelcase for all methods
\begin{clinee}
c++: DoomFixedToDouble(int doomFixed)
java: DoomFixedToDouble(int doomFixed)
\end{clinee}
\item State is changed structuraly: bufer and game variables are int tables (int[]). Whats more, getState copies the buffer and gameVariables, it doesn't happen in cpp. 
\item vectors in all functions  are changed to java tables.
\item Enumerations are created the same like in c++ (you have to use them like in java: )
\begin{clinee}
 dg.addAvailableButton(Button.ATTACK);
\end{clinee}
\item uint8\_t, unsigned int, size\_t are changed to int
\end{itemize}
\section{Extended Examples}
