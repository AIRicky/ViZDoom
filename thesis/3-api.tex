\chapter{Application Programming Interface}\label{ch:api}
\section{DoomGame Methods}\label{sec:methods}
	This section documents all methods implemented by DoomGame class which is a part of Vizia namespace (C++), vizia module (Python), or //TODO// (Java). DoomGame object incorporates a single instance of Doom game engine and is the way to interface with it.
	\subsection{Configuration Methods}\label{subsec:config_methods}
	Methods described in this section set main parameters of the environment, such as resolution of generated image or available actions. They should be invoked after creation and before the initialization method (\emph{init}). Calling them after initialization will result in a warning or an exception, depending on severity of consequences. 
	\vspace{20pt}

\begin{clinee}
DoomGame::DoomGame();
\end{clinee}

Constructs an instance of DoomGame. Zdoom engine is not ready for using after creation and needs initialization (init method). Freshly created DoomGame is initialized with the following parameters:
%maybe some reference to where we describe what it all means . . .if we do anywhere . . .
	\begin{itemize}
		\item screenResolution: RES\_320x240
		\item screenFormat: CRCGCB
		\item Game path: `./viziazdoom'
		\item Game iwad path: `./doom2.wad'
		\item map: `map01' (first map created in the iwad file if it's not changed purposefully)
		\item mode: PLAYER
		\item gameVariables: none
		\item customGameArgs: none
		\item available buttons: none
		\item rendering: all without crosshair
		\item windowVisible: true 
		\item doomSkill: 3
		\item livingReward/deathPenalty: 0
		\item consoleEnabled: false
		\item startEpisodeTime: 1
		\item episodeTimeout: 0
	\end{itemize}

\vspace{20pt}
\begin{clinee}
DoomGame::~DoomGame();
\end{clinee}

Destroys DoomGame object and safely ends work of the environment.

\vspace{20pt}
\begin{clinee}
bool DoomGame::init();
\end{clinee}

Initializes the enviroment and spawns the Doom eginge process. Configuration cannot be changed after calling \emph{init} method. Init returns true when the game engine was started properly and flase otherwise. 


\vspace{20pt}
\begin{clinee}
bool DoomGame::loadConfig(std::string configFilePath);
\end{clinee}

Loads configuration (resolution, available buttons etc.) from a configuration file. Proper syntax of configuration files is described in Section~\ref{sec:configuration_file}. In case of multiple invocations, older configurations will be overwritten by the recent ones. Note that overwriting does not involve resetting to default values, thus only overlapping parameters will be changed. The method returns true if the whole configuration file was correctly read and applied, false if the file was inaccessible or contained errors.


\vspace{20pt}
\begin{clinee}
void DoomGame::addAvailableButton(Button button);
\end{clinee}

Makes the specified input type (e.g. TURN\_LEFT, MOVE\_FORWARD ) available (possible to use). If the given button has already been added the method has no effect. If the specified button supports non-boolean values, no maximum value constraint is set. For the full list of supported buttons see Section~\ref{subsec:button}.


\begin{clinee}
void DoomGame::setButtonMaxValue(Button button, int maxValue);
\end{clinee}
Sets the maximum allowed (absolute) value for the specified button. If the button has not been added yet it is not added, but the maximum value is set anywa. Setting maximum value equal to 0 results in no constraint at all (infinity). This method makes sense only for buttons that use non-boolean values:  
	\begin{itemize}
		\item LOOK\_UP\_DOWN\_DELTA
		\item TURN\_LEFT\_RIGHT\_DELTA
		\item MOVE\_FORWARD\_BACKWARD\_DELTA
		\item MOVE\_LEFT\_RIGHT\_DELTA
		\item MOVE\_UP\_DOWN\_DELTA
 	\end{itemize}
This method will work and take effect even after call to \emph{init} method.

\vspace{20pt}
\begin{clinee}
void DoomGame::addAvailableButton(Button button, int maxValue);
\end{clinee}
	Combines functionalities of \emph{addAvailableButton} and \emph{setMaxButtonValue} in one method. If the button has already been added the maximum value is overridden. 

\vspace{20pt}
\begin{clinee}
void DoomGame::clearAvailableButtons();
\end{clinee}
	Clears all available buttons addded so far.

\vspace{20pt}
\begin{clinee}
void DoomGame::addAvailableGameVariable(GameVariable var);
\end{clinee}
	Adds the specified GameVariable to the list of game variables(e.g. AMMO1, HEALTH, ATTACK\_READY) that are included in the game's state (returned by \emph{getState} method). For the full list of available game variables see Section~`{subsec:gamevar}.

\vspace{20pt}
\begin{clinee}
void DoomGame::clearAvailableGameVariables();
\end{clinee}
	Clears the list of available game variables that are included in the game's state (returned by \emph{getState} method).

\vspace{20pt}
\begin{clinee}
void DoomGame::addCustomGameArg(std::string arg);
\end{clinee}
	Adds a custom argument that will be passed to vizazdoom process during initialization. //TODO reference to wehere you can find possible arguments

\vspace{20pt}
\begin{clinee}
void DoomGame::clearCustomGameArgs();
\end{clinee}
	Clears all arguments previously added with \emph{addCustomGameArg} method.


\vspace{20pt}
\begin{clinee}
void DoomGame::setMode(Mode mode);
\end{clinee}
	Sets mode (e.g. PLAYER, SPECTATOR) in which the game will be started. For the full list of supported modes and their descriptions see Section~\ref{sec:architecture_modes}.

\vspace{20pt}
\begin{clinee}
void DoomGame::setDoomEnginePath(std::string path);
\end{clinee}

Sets path to Doom engine executable.


\vspace{20pt}
\begin{clinee}
void DoomGame::setDoomGamePath(std::string path);
\end{clinee}

Sets path to the Doom engine based game file (wad format).


\vspace{20pt}
\begin{clinee}
void DoomGame::setDoomScenarioPath(std::string path);
\end{clinee}
	Sets path to additional file or files (e.g. scenario).

\vspace{20pt}
\begin{clinee}
void DoomGame::setDoomConfigPath(std::string path);
\end{clinee}
	Sets path for Doom configuration file. This configuration file is \emph{not} Vizia's configuration file that can be loaded and affects initialization parameters such as available buttons or screen resolution. The file in question is responsible for configuration of Doom engine itself (key bindings etc.) and is created after viziazdoom executable is run for the first time. This method is not needed for most of the tasks and is added for convinience of users with hacking tendencies. For more details consult Zdoom Wiki Webpage\cite{zdoom-wiki}.

\vspace{20pt}
\begin{clinee}
void DoomGame::setDoomMap(std::string map);
\end{clinee}
	Sets the map to be used.


\vspace{20pt}
\begin{clinee}      
void DoomGame::setDoomSkill(int skill);
\end{clinee}
	Sets Doom game difficulty level (0-4) which is called `skill' in Doom. The higher is the skill ther harder the game becomes. Skill level affects monster' aggressiveness, monster's speed, weapon damage, ammunition quantities etc. For more details consult Zdoom Wiki Webpage\cite{zdoom-wiki}.

\vspace{20pt}
\begin{clinee}    
void DoomGame::setEpisodeStartTime(unsigned int tics);
\end{clinee}

Sets start delay of every episodes in doom tics. Every episode will effectively start (from the user's perspective) after given number of tics.


\vspace{20pt}
\begin{clinee}
void DoomGame::setEpisodeTimeout(unsigned int tics);
\end{clinee}

Sets quantity of tics after which the episode will be finished. 0 will result in no timeout.


\vspace{20pt}
\begin{clinee}
void DoomGame::setLivingReward(double livingReward);
\end{clinee}

Sets the reward granted to the player for each action (no matter if he survives it). A negative value will result in living penalty rather than a reward.


\vspace{20pt}
\begin{clinee}
void DoomGame::setDeathPenalty(double deathPenalty);
\end{clinee}
	Sets a penalty for player's death. Note that in case of a negative value, the player will be rawarded upon dying.

\vspace{20pt}
\begin{clinee}
void DoomGame::setScreenResolution(ScreenResolution resolution);
\end{clinee}
	Sets the screen resolution. Supported resolutions are part of ScreenResolution enumeration type and their format is: RES\_xXy (e.g. RES\_320X240, RES\_1920X1080). The buffer as well as content of zdoom's display window will be affected. For the full list of supported resolutions see Section~\ref{subsec:resolution}.

\vspace{20pt}
\begin{clinee}
void DoomGame::setScreenFormat(ScreenFormat format);
\end{clinee}
	Sets the format of the screen buffer. Supported formats are defined in ScreenFormat enumaration type(e.g. CRCGCB, RGB24, GRAY8). The format change affects only the buffer so it will not have any effect on the content of zdoom's display window. To see the full list of supported screen formats see Section~\ref{subsec:screenformat}.


\vspace{20pt}
\begin{clinee}       
void DoomGame::setRenderHud(bool hud);
void DoomGame::setRenderWeapon(bool weapon);
void DoomGame::setRenderCrosshair(bool crosshair);
void DoomGame::setRenderDecals(bool decals);
void DoomGame::setRenderParticles(bool particles);
\end{clinee}
	Methods that determine if elements specified in the methods' names (hud, weapon, crosshair, decals and particles) will be displayed.


\vspace{20pt}
\begin{clinee}
void DoomGame::setWindowVisible(bool visibility);
\end{clinee}
	Determines if zdoom's window will be visible.
	Turning visibility off will result in:
	\begin{itemize}
		\item Linux - rendering and any computations connected with the window will be skipped. Processing acceleration should be expected.
		\item Windows - window will be hidden. No processing acceleration should be expected.
	\end{itemize}


\vspace{20pt}
\begin{clinee}
void DoomGame::setConsoleEnabled(bool console);
\end{clinee}
	Determines if Zdoom's and Vizia's console output will be enabled(e.g. `You picked up a medpac', `Player killed himself.', `Vizia\_init')


\vspace{20pt}
\subsection{Runtime Methods}\label{subsec:runtime_methods}
	The following methods directly interact with the game's state and should be used after inicialization. Calling them before \emph{init} method will result in a warning or exception depending on severity of consequences. 

\vspace{20pt}
\begin{clinee}
void DoomGame::newEpisode();
\end{clinee}
	Initializes a new episode. All rewards and map states are restarted.


\vspace{20pt}
\begin{clinee}
	void DoomGame::setAction(std::vector<int> const &actions);
\end{clinee}
	Sets the player's behavior in the next tic.
	Each vector's value corresponds to a button specified with \emph{addAvailableButton} method or in configuration files (in order of appearance).

\vspace{20pt}
\begin{clinee}
	void DoomGame::advanceAction();
\end{clinee}
	Performs a single tic using the action set with \emph{setAction}. After the call, action vector is not reset and will be used once again if not changed before the next advance.


\vspace{20pt}
\begin{clinee}
	void DoomGame::advanceAction(bool stateUpdate, bool renderOnly, unsigned int tics);
\end{clinee}
	Performs a specified number of tics using the action set with \emph{setAction}. After the call, action vector is not reset and will be used once again if not changed before the next advance.


\vspace{20pt}
\begin{clinee}
	double DoomGame::getLastReward();
\end{clinee}
	Returns a reward granted after last \emph{advanceAction}. If a single action lasted longer then one tic, the cumulative reward from all tics will be returned.


\vspace{20pt}
\begin{clinee}
	double DoomGame::makeAction(std::vector<int> const &actions);
\end{clinee}

Function combining usibility of setAction(), advanceAction() and getLastReward(). It sets the player's behavior in the next tic, performes one and returns reward.
Each vector's value corresponds to button specified with addAvailableButton() function (in invocation order).
In case of possitive value, picked action will be triggered with the specified strength. Descrete actions (e.g. ATTACK) will be performed once. 


\vspace{20pt}
\begin{clinee}
	double DoomGame::makeAction(std::vector<int> const &actions, unsigned int tics);
\end{clinee}

Function combining usibility of setAction(), advanceAction() and getLastReward(). It sets the player's behavior in the next number of tics given to the function, performes it and returns cumulative reward from all tics. Each vector's value corresponds to button specified with addAvailableButton() function (in invocation order). Descrete actions (e.g. ATTACK) will be only performed in the first tic, analog actions (moving, turning) will be repeated every tic with given strength.
State will be updated after that. Buffer will not be updated.


\vspace{20pt}
\begin{clinee}
	DoomGame::State DoomGame::getState();
\end{clinee}

	Returns DoomGame::State structure with the current game state. For more details see Section~\ref{sec:structs}.


\vspace{20pt}
\begin{clinee}
	std::vector<int> DoomGame::getLastAction();
\end{clinee}
	Returns a vector with the last action performed. Each vector's value corresponds to a button added with \emph{addAvailableButton} (in order of appearance). Most usefull in SPECTATOR mode.


\vspace{20pt}
\begin{clinee}
	uint8_t * const getGameScreen();
\end{clinee}
	Returns a pointer the screen buffer. //TODO

\vspace{20pt}
\begin{clinee}
	int DoomGame::getGameVariable(GameVariable var);
\end{clinee}

	Returns the current value of the specified game variable (AMMO1, HEALTH etc.). The specified game variabled does not need to be among available game variables (included in the state).
	It could be used for e.g. shaping. Returns 0 in case of not finding given GameVariable.


\vspace{20pt}
\begin{clinee}
	double DoomGame::getSummaryReward();
\end{clinee}

	Returns the sum of all rewards gathered in the current episode.


\vspace{20pt}
\begin{clinee}
	bool DoomGame::isNewEpisode();
\end{clinee}

	Returns true if the current episode is in the initial state (no actions were performed yet).


\vspace{20pt}
\begin{clinee}
	bool DoomGame::isEpisodeFinished();
\end{clinee}
	Returns true if the current episode is in the terminal state (is finished). \emph{MakeAction} and \emph{advanceAction} methods should not be called after this point (unless \emph{newEpisode} method is called).


\vspace{20pt}
\begin{clinee}
	void DoomGame::setSeed(unsigned int seed);
\end{clinee}

	Sets the seed of the randomizing engine. Using the same seed and actions in another episode will result in exactly the same gameplay (granted that the same actions will be performed).


\vspace{20pt}
\begin{clinee}
	void DoomGame::close();
\end{clinee}
	Closes Zdoom engine and corresponding processes. Metod frees used resources (memory allocations etc.). It is automatically invoked by the destructor so it is necessary only when there is a need to close zdoom engine in the middle of processing.


\vspace{20pt}
\begin{clinee}
	bool DoomGame::isRunning();
\end{clinee}
	Checks if the current zdoom process is running.


\vspace{20pt}
\begin{clinee}
	void DoomGame::sendGameCommand(std::string cmd);
\end{clinee}
	Sends the command to zdoom console. Can be used for cheats, multiplayer etc. For more details consult Zdoom Wiki Webpage\cite{zdoom-wiki}.

\vspace{20pt}
\subsection{Query Methods}

DoomGame provides a number of getters associated with configuration methods described in Section~\ref{subsec:config_methods}. Getters can be used before and after initialization and return values of parameters that are specified in their names.

\vspace{20pt}
\begin{clinee}
int DoomGame::getAvailableButtonsSize();
int DoomGame::getAvailableGameVariablesSize();
Mode DoomGame::getMode();
double DoomGame::getLivingReward();
double DoomGame::getDeathPenalty();
unsigned int DoomGame::getEpisodeStartTime();
unsigned int DoomGame::getEpisodeTimeout();
unsigned int DoomGame::getEpisodeTime();
int DoomGame::getScreenWidth();
int DoomGame::getScreenHeight();
int DoomGame::getScreenChannels();
size_t DoomGame::getScreenPitch();
size_t DoomGame::getScreenSize();
ScreenFormat DoomGame::getScreenFormat();
unsigned int DoomGame::getSeed();
int DoomGame::getButtonMaxValue(Button button);
\end{clinee}


\section {Utility Functions}
In addition to DoomGame class, Vizia provides 3 utility functions that may be help with interaction with the Doom engine.

\vspace{20pt}
\begin{clinee}
unsigned int DoomTics2Ms(unsigned int tics);
\end{clinee}
	Calculates the number of milliseconds that will pass after specified number of tics (assuming 35 tics per second - designed Doom ticrate).


\vspace{20pt}
\begin{clinee}
unsigned int Ms2DoomTics(unsigned int ms);
\end{clinee}

	Calculates how many tics will be made during given number of milliseconds (assuming 35 ticks per second - designed Doom ticrate).


\vspace{20pt}
\begin{clinee}
double DoomFixedToDouble(int doomFixed);
\end{clinee}
	Converts Doom's fixed point numeral to a double value.


\vspace{20pt}
\section{Structures and Enumerations} \label{sec:structs}
\subsection{State}

A structure that represents the current state of the game.

\vspace{20pt}	
\begin{clinee}
	struct State {
	    unsigned int number; 
	    std::vector<int> gameVariables;
	    uint8_t * imageBuffer;
	};
\end{clinee}
\begin{description}
	\item[number] State's ordinal number in the current episode.
	\item[gameVariables] Vector storing game variables (e.g. AMMO, HEALTH) specified in configuration. 
	\item[imageBuffer] Pointer to the screen buffer containing the image information.
\end{description}
\subsection{Mode}\label{subsec:mode}
Enumeration type representing available game modes. For datailed description of all modes see Section~\ref{sec:architecture_modes}

\paragraph{Modes:}

\begin{itemize}
	\item PLAYER
	\item SPECTATOR
	\item ASYNC\_PLAYER 
	\item ASYNC\_SPECTATOR 
\end{itemize}

\subsection{ScreenFormat}\label{subsec:screenformat}
Enumeration type representing the screen format in witch the game screen buffer will be kept. 


\vspace{20pt}
\textbf{ScreenFormats:}
\begin{itemize}
 \item CRCGCB 
 \item CRCGCBDB
 \item RGB24
 \item RGBA32
 \item ARGB32
 \item CBCGCR
 \item CBCGCRDB
 \item BGR24
 \item BGRA32
 \item ABGR32
 \item GRAY8
 \item DEPTH\_BUFFER8
 \item DOOM\_256\_COLORS
\end{itemize}
\subsection{ScreenResolution} \label{subsec:screenresolution}
Enumeration type representing the screen resolutions. Because of the terrifying multitude of possible resolutions only a couple of sample resolutions are listed here. For the full list of resolutions see Apendix ~\ref{sec:appendix_structs_and_enums}.


\vspace{20pt}
\textbf{ScreenResolution sample values:}
\begin{itemize}
\item RES\_40X30
\item RES\_160X120	
\item RES\_480X270	
\item RES\_480X360	
\item RES\_800X600
\item RES\_5120X2880
\end{itemize}

\subsection{GameVariable} \label{subsec:gamevar}
Enumeration type representing various game parameters like player's health or ammunition.


% TODO list and describe them all
\vspace{20pt}
\textbf{Game Variables:}
\begin{itemize}
	\item KILLCOUNT\\
	\item ITEMCOUNT\\
	\item HEALTH\\
	\item AMMO1\\
	\item AMMO2\\
	\item WEAPON1
	\item WEAPON2\\
	\item USER1\\
\end{itemize}

\subsection{Button} \label{subsec:button}
Enumeration type representing the possible prime factors that constitute a single action. Some of them can be further configured with a value indicating the angle of rotation or shift done in a single call. If not set, default force is used. Setting this additional value to the simple button without this option will not affect its call. If action lasting longer than 1 tic is performed, buttons correlated with move will be made continuously when simple actions will be made once in the first tic. Their full list can be found in the apendix.

% TODO write about distinction between binary and delta buttons
% TODO list and describe them all
\vspace{20pt}
\textbf{Binary Buttons Examples:}
\begin{itemize} 
	\item ATTACK
	\item MOVE\_FORWARD
	\item MOVE\_RIGHT
	\item TURN\_LEFT
	\item USE
\end{itemize}

\vspace{20pt}
\textbf{Delta Buttons:}
\begin{itemize} 
	 \item LOOK\_UP\_DOWN\_DELTA
	 \item TURN\_LEFT\_RIGHT\_DELTA
	 \item MOVE\_FORWARD\_BACKWARD\_DELTA
	 \item MOVE\_LEFT\_RIGHT\_DELTA
	 \item MOVE\_UP\_DOWN\_DELTA
\end{itemize}

\section{Configuration file}\label{sec:configuration_file}


Configuration file stores group of parameters and initial settings for the future use. It can be loaded into the game before inicialization. Settings can be overwritten after that action, giving the possibility of changing sigle parameter without interference in the file itself. There should be met certain requirements as to its content and name to make it load successfully.

Name of the configuration file should be with .properties suffix.

Content of the file should be composed of keywords identifying the setting and the value assigned to it separated with '='. Keyword is constructed similarly to the setting name, for example: episodeStartTime, windowVisible. However, two of them differ: availablebuttons, availablegamevariables.
Keyword can be written in both underscore and camel notation (case-insensitive). 


Value should be placed after '=' sign. File paths should not be placed between "" marks like the rest of the string values.
\begin{pblock}
...
#Values
living_reward = -1
render_crosshair = false
#Path
doom_iwad_path = ../../scenarios/doom2.wad
doom_file_path = ../../scenarios/basic.wad
#Normal String
doom_map = "map01"
...
\end{pblock}
Enum values should be passed using their name.
\begin{pblock}
...
#Enums
screen_format = CRCGCB
mode = PLAYER
...
\end{pblock}
Each setting should be separated from each other by a sign of the new line. In order to improve readability, it's possible to add a comment line by adding a '\#' sign at the beginning of the new line.

An exceptionally behave here availablebuttons and availablegamevariables functions because instead of individual variables, take as an argument the list of values in '\{\}'. The individual components should be separated from each other by a newline.
\begin{pblock}
...
# Available buttons
available_buttons = 
	{ 
		MOVE_LEFT 
		MOVE_RIGHT 
		ATTACK 
	}
# Game variables that will be in the state
available_game_variables = { AMMO2}
...
\end{pblock}

\section{Wrappers}
\subsection{Python}

Python functions and metods are very similar to the c++ ones. Howewer, because of the language differences, some of the values may vary. All differences are listed below.

\paragraph {Naming}
Naming convention used in python binding is underscore. The only exception is the constructor which is named in the same way like in c++.

\begin{cblock}
c++: DoomFixedToDouble(int doomFixed)
python: doom_fixed_to_double(int doomFixed)
\end{cblock}


\paragraph {Structures}
 State is changed structuraly: bufer is a numpy array and game variables are contained in a Python list. Whats more, getState() copies the buffer and gameVariables what doesn't happen in cpp. 
\paragraph {Enumerations}
Python equivalent of enums were created with the same names.
\begin{cblock}
game.add_available_button(Button.TURN_LEFT_RIGHT_DELTA)
game.add_available_button(Button.MOVE_LEFT)
\end{cblock}
\paragraph {Types}
Due to the languages differences, some types have been modified.
\begin{itemize} 
\item Vectors in all functions were changed to python lists of compatible type.

\item  uint8\_t, unsigned int, size\_t were changed to int
\end{itemize}



\subsection{Java}
Java, like python, is a bit different then c++. All differences and the most important principles of using are listed below.

\paragraph {Naming}
 Naming convention is camelcase, the same like in c++. 
\begin{cblock}
c++: DoomFixedToDouble(int doomFixed)
java: DoomFixedToDouble(int doomFixed)
\end{cblock}
\paragraph {Structures}
State is changed structuraly: bufer and game variables are int tables (int[]). Whats more, getState() copies the buffer and gameVariables what doesn't happen in cpp. 
\paragraph {Enumerations}
Java equivalent of enums were created with the same names.
\begin{cblock}
dg.addAvailableButton(Button.ATTACK);
dg.addAvailableButton(Button.MOVE_LEFT);
\end{cblock}
\paragraph {Types}
Due to the languages differences, some types have been modified.
\begin{itemize}
\item Vectors in all functions were changed to java tables of compatible type (vector<int> = int[]).
\item uint8\_t, unsigned int, size\_t were changed to int
\end{itemize}
\section{Extended Examples}
\subsection{Spectator mode}
Spectator mode is designed to enable artificial intelligence to learn directly from humans game.
Python listing presented below demonstrates the use of this option in which a human takes control over the game and Intelligent Agent looks at and analyzes the movements. In this synchronous mode, Artificial Intelligence has power over the engine and decides when human can make the next move. 


After the initial configuration in which available actions and collected variables from the game are set, the script runs sequence of 10 episodes. During their run, the image is downloaded and the human gets the opportunity to perform a single action which are then read and stored by the script. After this process, processing of AI follows. Downloaded data is printed at the end of the loop, such as the values of game variables set in the game and operations taken with associated reward. What's more, before the end of each episode, a summary is displayed followed by 2 second delay.

\begin{pblock}
from __future__ import print_function
from vizia import *
from time import sleep

game = DoomGame()
game.load_config("config_deathmatch.properties")
game.set_screen_resolution(ScreenResolution.RES_640X480)
game.add_available_button(Button.TURN_LEFT_RIGHT_DELTA)
game.set_window_visible(True)
game.set_mode(Mode.SPECTATOR)
game.init()

episodes = 10
print("")
for i in range(episodes):
	print("Episode #" +str(i+1))
	
	game.new_episode()
	while not game.is_episode_finished():
		
		s = game.get_state()
		img = s.image_buffer
		misc = s.game_variables

		game.advance_action()
		a = game.get_last_action()
		r = game.get_last_reward()
		...		
		#IA processing
		...
		print("state #"+str(s.number))
		print("game variables: ", misc)
		print("action:", a)
		print("reward:",r)
		print("=====================")

	
	print("episode finished!")
	print("summary reward:", game.get_summary_reward())
	print("************************")
	sleep(2.0)

game.close()
\end{pblock}

\subsection {Seed}
Seed setting was created to enable running deterministic episodes. Thanks to that, if agent behaves in the same way, each episode can be recreated.

The following listing demonstrates usiage of a seed in the script. Once it is set along with other parameters in the configuration phase, list of all possible actions is made. In each episode, state of the game is processed and action is made based on AI decision. In that point, operation taken in the game should be saved to make it possible to recreate the episode in the future. Downloaded data is printed at the end of the loop, such as game state number, the values of variables set in the game and reward for last action made. After each episode, quick summary is displayed. To recreate one of the episodes, the same seed should be set and the same actions in wright time should be taken.

\begin{pblock}
from __future__ import print_function
from vizia import *
from random import choice
import itertools as it
from time import sleep

game = DoomGame()

game.load_config("config_basic.properties")
game.set_screen_resolution(ScreenResolution.RES_640X480)

seed = 1234
# Sets the seed.
game.set_seed(seed)

game.init()

# Creates all possible actions depending on how many buttons there are.
actions_num = game.get_available_buttons_size()
actions = []
for perm in it.product([False, True], repeat=actions_num):
    actions.append(list(perm))

episodes = 10
sleep_time = 0.028

for i in range(episodes):
	print("Episode #" + str(i+1))
	game.new_episode()

	while not game.is_episode_finished():
		# Gets the state and possibly do something with it
		s = game.get_state()
		img = s.image_buffer
		misc = s.game_variables

		...
		# IA processing
		...		
		
		# Check which action you chose and save it!
		r = game.make_action(choice(actions))
		
		
		print("State #" + str(s.number))
		print("Game Variables:", misc)
		print("Last Reward:", r)
		print("=====================")

	print("Episode finished!")
	print("Summary reward:", game.get_summary_reward())
	print("************************")


game.close()
\end{pblock}

\subsection {Multiplayer}
Multiplayer mode was configured to enable creating deathmatch between human and AI (or only AI). To create such game, at least two scripts should be prepered.

\paragraph{Host player}
To create the game, host player script should be implemented with all appropriate configuration. After setting basic options like resolution and gamemode (asynchronous should be used), some addition game arguments should be passed using addCustomGameArg() function. They define max number of players, variant of the game and used map. In the following script, Spectator mode is picked and AI is only processing image data and updating game state using advance\_action(). At the end of each loop, log is displayed on the console window.

\begin{pblock}
from __future__ import print_function
from vizia import *
from random import choice
from time import sleep
from time import time

game = DoomGame()
game.load_config("config_multi.properties")
game.add_custom_game_arg("-host")
game.add_custom_game_arg("2")
game.add_custom_game_arg("-deathmatch")
game.add_custom_game_arg("-warp")
game.add_custom_game_arg("-01")
game.set_mode(Mode.ASYNC_SPECTATOR)
game.init()

	
episodes = 1

for i in range(episodes):
	
	while not game.is_episode_finished():	
		s = game.get_state()
		img = s.image_buffer
		misc = s.game_variables

		game.advance_action()
		a = game.get_last_action()
		r = game.get_last_reward()
			
		print("state #"+str(s.number))
		print("game variables: ", misc)
		print("action:", a)
		print("reward:", r)
		print("=====================")
	
print("episode finished!")
print("summary reward:", game.get_summary_reward())
print("************************")

game.close()
\end{pblock}


To join an existing game, some additional configuration using game arguments should be made. Host player should be pointed by passing his ip number. In followinig egzample, AI can make 3 types of actions: shoot, move left or move right. It is picked after image processing. At the end of each loop, log is displayed on the console window.

\begin{pblock}
from __future__ import print_function
from vizia import *
from random import choice
from time import sleep
from time import time



game = DoomGame()
game.load_config("config_multi.properties")

game.add_available_button(Button.ATTACK)
game.add_available_button(Button.MOVE_LEFT)
game.add_available_button(Button.MOVE_RIGHT)
game.set_mode(Mode.ASYNC_PLAYER)
game.add_custom_game_arg("-join")
game.add_custom_game_arg("127.0.0.1")
game.set_window_visible(False)
game.init()


actions = [[1,0,0],[0,1,0],[0,0,1]]

episodes = 1

for i in range(episodes):
	
	while not game.is_episode_finished():	
		s = game.get_state()
		img = s.image_buffer
		misc = s.game_variables

		game.make_action(choice(actions))
		a = game.get_last_action()
		r = game.get_last_reward()
			
		print("state #"+str(s.number))
		print("game variables: ", misc)
		print("action:", a)
		print("reward:", r)
		print("=====================")
	
	print("episode finished!")
	print("summary reward:", game.get_summary_reward())
	print("************************")

game.close()
\end{pblock}

