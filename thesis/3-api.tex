
\chapter{Application Programming Interface}
\section{Methods}
	\subsection{Configuration}
	Methods described below are setting the main parameters of the environment, such as resolution of the generated image or Intelligent Agent's available actions. They should be invoked before the init() method. Any attempt to invoke them after initialization will result in a warning/exception depending on severity of consequences. 
	\vspace{20pt}

		\begin{clinee}
		DoomGame();
		\end{clinee}

Constructor that creates an instance of the game. Zdoom is not ready for action after the constructor, it needs further initialization. Object is inicialized with the following values:
	\begin{itemize}
\item Resolution: 640x480
\item Game path: ./viziazdoom
\item Game iwad path: "./doom2.wad"
\item Map: map01 (first map created in the iwad file if it's not changed purposefully)
\item Mode: PLAYER
\item GameVariables: none
\item CustomGameArg: none
\item Available buttons: ATTACK, USE, JUMP, CROUCH, SPEED, MOVE\_RIGHT, MOVE\_LEFT, MOVE\_BACKWARD, MOVE\_FORWARD, TURN\_RIGHT, TURN\_LEFT
\item Rendering: All
\item Window: displayed 
\item DoomSkill: ??????????
\item Co z tymi autostartami i rewardami?
	\end{itemize}


\vspace{20pt}
\begin{clinee}
~DoomGame();
\end{clinee}

The destructor that safely ends the work of environment and removes the object.


\vspace{20pt}
\begin{clinee}
bool init();
\end{clinee}

Function which initializes enviroment. Configuration cannot be changed after invokation of init(). Dooms instance is created in separate process. Returns true when game was started properly. 


\vspace{20pt}
\begin{clinee}
bool loadConfig(std::string filename);
\end{clinee}

Loads and sets configuration from a configuration file. It's syntax is better described in Section~\ref{sec:configuration_file}. The configuration file can substitute any combination of the following methods call. In case of multiple invokations, they will overwrite selected settings from previous calls. Return true when all configuration was read properly.


\vspace{20pt}
\begin{clinee}
void addAvailableButton(Button button);
\end{clinee}

Adds support for the specified actions (e.g. TURN\_LEFT, MOVE\_FORWARD ). If no buttons are specified (the method is not called) 11 default buttons are added. Their list may be found in constructor description.


\vspace{20pt}
\begin{clinee}
void addAvailableButton(Button button, int maxValue);
\end{clinee}

Adds support for the specified actions responsible for rotation and sets the amount of movement done. It only applies to "buttons" responsible for rotation. it effectively constraints rotation speed. %TODO CO TO ROBI?!


\vspace{20pt}
\begin{clinee}
void setButtonMaxValue(Button button, int maxValue);
\end{clinee}

Sets the button's max value. It only applies to "buttons" responsible fors rotation and moving(with specified speed), it effectively constraints rotation/moving speed.
0 means no constraint and it's the default behavior TODO %TODO CO TO ROBI?!


\vspace{20pt}
\begin{clinee}
void addAvailableGameVariable(GameVariable var);
\end{clinee}

Adds given GameVariable to the list of values returned in getState() (e.g. AMMO1, HEALTH, ATTACK\_READY).


\vspace{20pt}
\begin{clinee}
void clearAvailableButtons();
\end{clinee}

Disables support for any specified buttons. It will result in default setting which can be found in constructor description.


\vspace{20pt}
\begin{clinee}
void clearAvailableGameVariables();
\end{clinee}

Clears the list of game variables returned in getState().


\vspace{20pt}
\begin{clinee}
void addCustomGameArg(std::string arg);
\end{clinee}

Adds a custom argument for the zdoom process. %TODO OPIS


\vspace{20pt}
\begin{clinee}
void clearCustomGameArgs();
\end{clinee}

Clears all arguments specified by addCustomGameArg().


\vspace{20pt}
\begin{clinee}
void setMode(Mode mode);
\end{clinee}

Sets mode in which the game will be started. Supported formats are defined in Mode enumaration (e.g. PLAYER, SPECTATOR).


\vspace{20pt}
\begin{clinee}
void setDoomGamePath(std::string path);
\end{clinee}

Sets path to zdoom executable.


\vspace{20pt}
\begin{clinee}
void setDoomIwadPath(std::string path);
\end{clinee}

Sets path to the game iwad file.


\vspace{20pt}
\begin{clinee}
void setDoomFilePath(std::string path);
\end{clinee}

Sets path to additional iwad file (e.g. scenario).


\vspace{20pt}
\begin{clinee}
void setDoomMap(std::string map);
\end{clinee}

Sets map to be used by doom.


\vspace{20pt}
\begin{clinee}      
void setDoomSkill(int skill);
\end{clinee}

Sets doom game difficulty level (0-5) which is called skill in doom. Less means easier. It affects ammo, life amount and monster aggressiveness. %TODO co tutaj? 


\vspace{20pt}
\begin{clinee}
void setDoomConfigPath(std::string path);
\end{clinee}

Sets path for doom configuration file.


\vspace{20pt}
\begin{clinee}    
void setEpisodeStartTime(unsigned int tics);
\end{clinee}

Sets start delay of every episodes in doom tics. Every episode will effectively start (from the user's perspective) after given number of tics.


\vspace{20pt}
\begin{clinee}
void setEpisodeTimeout(unsigned int tics);
\end{clinee}

Sets quantity of tics after which the episode will be finished.


\vspace{20pt}
\begin{clinee}
void setLivingReward(double livingReward);
\end{clinee}

Sets the reward granted for player being alive after each tic.


\vspace{20pt}
\begin{clinee}
void setDeathPenalty(double deathPenalty);
\end{clinee}

Sets penalty for player's death. In case of negative value, player will be rawarded for each decease.


\vspace{20pt}
\begin{clinee}
void setAutoNewEpisode(bool set);
\end{clinee}

Determines if automatic episode restart will be set in case of the end of previous one.


\vspace{20pt}
\begin{clinee}
void setNewEpisodeOnTimeout(bool set);
\end{clinee}

Determines if automatic episode restart will be set in case of the timeout.


\vspace{20pt}
\begin{clinee}
void setNewEpisodeOnPlayerDeath(bool set);
\end{clinee}

Determines if automatic episode restart will be set in case of players death.


\vspace{20pt}
\begin{clinee}
void setNewEpisodeOnMapEnd(bool set);
\end{clinee}

Determines if automatic episode restart is set when player reaches the end of the map.


\vspace{20pt}
\begin{clinee}
void setScreenResolution(ScreenResolution resolution);
\end{clinee}

Sets screen resolution. Supported resolutions are part of ScreenResolution Enumeration type and their format is: RES\_xXy (e.g. RES\_320X240, RES\_1920X1080). Buffer as well as content of zdoom's window is affected.


\vspace{20pt}
\begin{clinee}
 void setScreenFormat(ScreenFormat format);
\end{clinee}

Sets format of the screen buffer. Supported formats are defined in ScreenFormat enumaration (e.g. CRCGCB, RGB24, GRAY8). Content displayed in zdoom's window what change no matter which format you choose - it only affects the buffer.


\vspace{20pt}
\begin{clinee}       
void setRenderHud(bool hud);
void setRenderWeapon(bool weapon);
void setRenderCrosshair(bool crosshair);
void setRenderDecals(bool decals);
void setRenderParticles(bool particles);
\end{clinee}

Methods that determine if some elements (hud, weapon, crosshair, decals, particles) will be displayed.


\vspace{20pt}
\begin{clinee}
void setWindowVisible(bool visibility);
\end{clinee}

Determines if zdoom's window will be visible.
Turning it off will result in:
\begin{itemize}
\item Linux - rendering and any computations connected with the window will be skipped. It results in processing acceleration
\item Windows - window will be hided. No processing acceleration
\end{itemize}


\vspace{20pt}
\begin{clinee}
void setConsoleEnabled(bool console);
\end{clinee}

Determines if zdoom's and vizia's console output will be displayed (e.g. "You picked up a medpack", "Player killed himself.", "Vizia\_init ....")


\vspace{20pt}
\subsection{Runtime}
The following methods handles gameplay. They directly affect the game and should be used after inicialization. 
Any attempt to invoke them before it will result in a warning/exception depending on severity of consequences. 


\vspace{20pt}
\begin{clinee}
void newEpisode();
\end{clinee}

Initializes new episode. All rewards, map state etc are restarted.


\vspace{20pt}
\begin{clinee}
	void setAction(std::vector<int> &actions);
\end{clinee}

Sets the player's behavior in the next tic.
Each vector's value corresponds to button specified with addAvailableButton() function (in invocation order).
In case of possitive value, picked action will be triggered with the specified strength. Descrete actions (e.g. ATTACK) will be performed once.


\vspace{20pt}
\begin{clinee}
	void advanceAction();
\end{clinee}

Method performs a tic using action obtained by setAction(). After function call, action vector is not reseted and will be performed once again if not changed.


\vspace{20pt}
\begin{clinee}
	void advanceAction(bool stateUpdate, bool renderOnly, unsigned int tics);
\end{clinee}

Method performs a given number of tic in the row. Descrete actions (e.g. ATTACK) will be only performed in the first tic, analog actions (moving, turning) will be repeated every tic. 
Function also determines if state should be updated. What's more, setting renderOnly option as true will disable buffer update. Hovewer, it will not affect zdoom main window.  


\vspace{20pt}
\begin{clinee}
	double getLastReward();
\end{clinee}

Returns the reward from last advanceAction. If a single action lasted longer then one tick, function it will return cumulative reward from all tics.


\vspace{20pt}
\begin{clinee}
	double makeAction(std::vector<int> &actions);
\end{clinee}

Function combining usibility of setAction(), advanceAction() and getLastReward(). It sets the player's behavior in the next tic, performe one and returns reward.
Each vector's value corresponds to button specified with addAvailableButton() function (in invocation order).
In case of possitive value, picked action will be triggered with the specified strength. Descrete actions (e.g. ATTACK) will be performed once. 


\vspace{20pt}
\begin{clinee}
	double makeAction(std::vector<int> &actions, unsigned int tics);
\end{clinee}

Function combining usibility of setAction(), advanceAction() and getLastReward(). It sets the player's behavior in the next number of tics given to the function, performes it and returns cumulative reward from all tics. Each vector's value corresponds to button specified with addAvailableButton() function (in invocation order). Descrete actions (e.g. ATTACK) will be only performed in the first tic, analog actions (moving, turning) will be repeated every tic with given strength.
State will be updated after that. Buffer will not be updated.


\vspace{20pt}
\begin{clinee}
	State getState();
\end{clinee}

Returns struct State with the current game state. More detailed description of the struct can be found in Section~\ref{sec:structs}.


\vspace{20pt}
\begin{clinee}
	std::vector<int> getLastAction();
\end{clinee}

Returns a vector with the last action performed. Each vector's value corresponds to button specified with addAvailableButton() function (in invocation order). Most usefull in SPECTATOR mode.


\vspace{20pt}
\begin{clinee}
	uint8_t * const getGameScreen();
\end{clinee}

Returns the screen buffer. Values depend on the settings set befor inicialization. The same value may be found in State structure. Its length is returned in getScreenPitch() function.


\vspace{20pt}
\begin{clinee}
	int getGameVariable(GameVariable var);
\end{clinee}

Returns value of the specified game variable (AMMO1, HEALTH etc.). It does not need to be a value returned in State.
It could be used for e.g. shaping. Returns 0 in case of not finding given GameVariable.


\vspace{20pt}
\begin{clinee}
	double getSummaryReward();
\end{clinee}

Returns sum of all rewards gathered in the current episode.


\vspace{20pt}
\begin{clinee}
	bool isNewEpisode();
\end{clinee}

Checks if the current episode is in the initial state. Returns true if no tic was performed.


\vspace{20pt}
\begin{clinee}
	bool isEpisodeFinished();
\end{clinee}

Checks if the current episode is in the terminal state. Returns true if the episode has ended. No makeAction/advanceAction functions should be called after this point.


\vspace{20pt}
\begin{clinee}
	void setSeed(unsigned int seed);
\end{clinee}

Sets the seed of the randomizing engine. Using the same seed and actions in another episode will affect in reproducing the gameplay.


\vspace{20pt}
\begin{clinee}
	void close();
\end{clinee}

Closes zdoom engine and corresponding processes. Metod frees used resources (memory allocations e.t.c). It is automatically invoked by destructor - should be used only when closing zdoom engine in the middle of processing is needed.


\vspace{20pt}
\begin{clinee}
	bool isRunning();
\end{clinee}

Checks if the current zdoom process is running.


\vspace{20pt}
\begin{clinee}
	void sendGameCommand(std::string cmd);
\end{clinee}

Sends a given command to zdoom console. Can be used for cheats, multiplayer e.t.c.


\vspace{20pt}
\subsection{QUERY INTERFACE}


Api provides a number of getters associated with the above-mentioned functions and a set of additional methods to help converts units.
  

\vspace{20pt}
\begin{clinee}
int getAvailableButtonsSize();
int getAvailableGameVariablesSize();
Mode getMode();
double getLivingReward();
double getDeathPenalty();
unsigned int getEpisodeStartTime();
unsigned int getEpisodeTimeout();
unsigned int getEpisodeTime();
int getScreenWidth();
int getScreenHeight();
int getScreenChannels();
size_t getScreenPitch();
size_t getScreenSize();
ScreenFormat getScreenFormat();
unsigned int getSeed();
int getButtonMaxValue(Button button);
\end{clinee}


\paragraph {Metods} Metods outsite the DoomClass:


\begin{clinee}
unsigned int DoomTics2Ms(unsigned int tics);
\end{clinee}

Function calculating number of milliseconds during given tics.


\vspace{20pt}
\begin{clinee}
unsigned int Ms2DoomTics(unsigned int ms);
\end{clinee}

Function calculating how many tics will be made during given number of milliseconds.


\vspace{20pt}
\begin{clinee}
double DoomFixedToDouble(int doomFixed);
\end{clinee}

DO OPISANIA


\vspace{20pt}
\section{Structures and Enumerations} \label{sec:structs}
\subsection{State}


Structure created to store all the information needed by inteligent agent to process the image.  
It is composed of three public fields:

\vspace{20pt}	
\begin{clinee}
	struct State {
	    unsigned int number; 
	    std::vector<int> gameVariables;
	    uint8_t * imageBuffer;
	};
\end{clinee}
number - Number of the state in the current episode. (tic number?)\\
gameVariables - vector storing user-defined, during the configuration, values drawn from the game such as AMMO or HEALTH 
imageBuffer - pointer to the screen buffer, containing the image information.
\begin{itemize}
\item struct state
\item enumeration types . . .or maybe move it to the apendinx?
\end{itemize}
\subsection{Mode}
Enumeration used to set the general game mode.
Posible values:
\begin{itemize}
\item PLAYER - 
\item SPECTATOR -
\item ASYNC\_PLAYER -
\item ASYNC\_SPECTATOR -
\end{itemize}
\subsection{ScreenFormat}
Enumeration used to set the general game mode.
\begin{itemize}
 \item CRCGCB 
 \item CRCGCBZB
 \item RGB24
 \item RGBA32
 \item ARGB32
 \item CBCGCR
 \item CBCGCRZB
 \item BGR24
 \item BGRA32
 \item ABGR32
 \item GRAY8
 \item ZBUFFER8
 \item DOOM\_256\_COLORS
\end{itemize}
\subsection{ScreenResolution}
\begin{itemize}
\item RES\_40X30,
 \item      RES\_60X45,
 \item       RES\_80X50,
 \item       RES\_80X60,
 \item       RES\_100X75,
 \item       RES\_120X75,
 \item       RES\_120X90
 \item       RES\_160X100,
 \item      RES\_160X120,
      \item  RES\_200X120,
      \item  RES\_200X150,
      \item  RES\_240X135,
      \item  RES\_240X150,
      \item  RES\_240X180,
      \item  RES\_256X144,
      \item  RES\_256X160,
      \item  RES\_256X192,
      \item  RES\_320X200,
      \item  RES\_320X240,
      \item  RES\_400X225,	// 16:9
      \item  RES\_400X300,
  \item      RES\_480X270,	// 16:9
 \item       RES\_480X360,
 \item       RES\_512X288,	// 16:9
 \item       RES\_512X384,
 \item       RES\_640X360,	// 16:9
 \item       RES\_640X400,
 \item       RES\_640X480,
 \item       RES\_720X480,	// 16:10
 \item       RES\_720X540,
 \item       RES\_800X450,	// 16:9
 \item       RES\_800X480,
 \item       RES\_800X500,	// 16:10
  \item      RES\_800X600,
 \item       RES\_848X480,	// 16:9
 \item       RES\_960X600,	// 16:10
 \item       RES\_960X720,
 \item       RES\_1024X576,	// 16:9
 \item       RES\_1024X600,	// 17:10
 \item       RES\_1024X640,	// 16:10
 \item       RES\_1088X612,	// 16:9
 \item       RES\_1152X648,	// 16:9
 \item       RES\_1152X720,	// 16:10
 \item       RES\_1152X864,
 \item       RES\_1280X720,	// 16:9
 \item       RES\_1280X854,
 \item       RES\_1280X800,	// 16:10
 \item       RES\_1280X960,
 \item       RES\_1280X1024,	// 5:4
 \item       RES\_1360X768,	// 16:9
 \item       RES\_1366X768,
 \item       RES\_1400X787,	// 16:9
 \item       RES\_1400X875,	// 16:10
 \item       RES\_1400X1050,
 \item       RES\_1440X900,
 \item       RES\_1440X960,
 \item       RES\_1440X1080,
  \item      RES\_1600X900,	// 16:9
 \item       RES\_1600X1000,	// 16:10
 \item       RES\_1600X1200,
 \item       RES\_1680X1050,	// 16:10
 \item       RES\_1920X1080,
 \item       RES\_1920X1200,
 \item       RES\_2048X1536,
 \item       RES\_2560X1440,
 \item       RES\_2560X1600,
 \item       RES\_2560X2048,
 \item       RES\_2880X1800,
 \item       RES\_3200X1800,
  \item      RES\_3840X2160,
 \item       RES\_3840X2400,
 \item       RES\_4096X2160,
  \item      RES\_5120X2880,
\end{itemize}
\subsection{GameVariable}
\begin{itemize}
\item KILLCOUNT,
\item        ITEMCOUNT,
\item        SECRETCOUNT,
\item        FRAGCOUNT,
\item        HEALTH,
\item        ARMOR,
\item        DEAD,
\item        ON\_GROUND,
\item        ATTACK\_READY,
\item        ALTATTACK\_READY,
 \item       SELECTED\_WEAPON,
\item      SELECTED\_WEAPON\_AMMO,
 \item       AMMO0,
\item        AMMO1,
\item        AMMO2,
\item        AMMO3,
 \item       AMMO4,
 \item       AMMO5,
 \item       AMMO6,
 \item       AMMO7,
\item       AMMO8,
\item        AMMO9,
 \item       WEAPON0,
 \item       WEAPON1,
\item        WEAPON2,
 \item       WEAPON3,
 \item       WEAPON4,
 \item       WEAPON5,
\item        WEAPON6,
\item        WEAPON7,
\item        WEAPON8,
\item        WEAPON9,
 \item       USER1,
 \item       USER2,
 \item       USER3,
 \item       USER4,
 \item       USER5,
\item        USER6,
\item        USER7,
\item        USER8,
\item        USER9,
\item        USER10,
\item        USER11,
\item        USER12,
\item        USER13,
\item        USER14,
\item        USER15,
\item        USER16,
\item        USER17,
\item        USER18,
\item        USER19,
\item        USER20,
\item        USER21,
\item        USER22,
\item        USER23,
\item        USER24,
\item        USER25,
\item        USER26,
\item        USER27,
\item        USER28,
\item        USER29,
\item        USER30,
\end{itemize}
\subsection{Button}
\begin{itemize}
\item ATTACK = 0,
\item         USE = 1,
\item         JUMP = 2,
\item         CROUCH = 3,
\item         TURN180 = 4,
\item         ALTATTACK = 5,
\item         RELOAD = 6,
\item         ZOOM = 7,

\item         SPEED = 8,
\item         STRAFE = 9,

\item         MOVE\_RIGHT = 10,
\item         MOVE\_LEFT = 11,
\item         MOVE\_BACKWARD = 12,
\item         MOVE\_FORWARD = 13,
\item         TURN\_RIGHT = 14,
\item         TURN\_LEFT = 15,
\item         LOOK\_UP = 16,
\item         LOOK\_DOWN = 17,
\item         MOVE\_UP = 18,
\item         MOVE\_DOWN = 19,
\item         LAND = 20,
        //SHOWSCORES 20

\item         SELECT\_WEAPON1 = 21,
\item         SELECT\_WEAPON2 = 22,
\item         SELECT\_WEAPON3 = 23,
\item         SELECT\_WEAPON4 = 24,
\item         SELECT\_WEAPON5 = 25,
\item         SELECT\_WEAPON6 = 26,
\item         SELECT\_WEAPON7 = 27,
\item         SELECT\_WEAPON8 = 28,
\item         SELECT\_WEAPON9 = 29,
 \item        SELECT\_WEAPON0 = 30,

\item     SELECT\_NEXT\_WEAPON = 31,
 \item        SELECT\_PREV\_WEAPON = 32,
\item         DROP\_SELECTED\_WEAPON = 33,

 \item        ACTIVATE\_SELECTED\_ITEM = 34,
 \item        SELECT\_NEXT\_ITEM = 35,
 \item        SELECT\_PREV\_ITEM = 36,
 \item        DROP\_SELECTED\_ITEM = 37,

 \item        LOOK\_UP\_DOWN\_DELTA = 38,
 \item        TURN\_LEFT\_RIGHT\_DELTA = 39,
 \item        MOVE\_FORWARD\_BACKWARD\_DELTA = 40,
 \item        MOVE\_LEFT\_RIGHT\_DELTA = 41,
 \item        MOVE\_UP\_DOWN\_DELTA = 42,
\end{itemize}
\section{Configuration file}\label{sec:configuration_file}


Configuration file stores group of parameters and initial settings for the future use. It can be loaded into the game before inicialization. Settings can be overwritten after that action, giving the possibility of changing sigle parameter without interference in the file itself. There should be met certain requirements as to its content and name to make it load successfully.

Name of the configuration file should be with .properties suffix.

Content of the file should be composed of keywords identifying the setting and the value assigned to it separated with '='. Keyword is constructed similarly to the setting name, for example: episodeStartTime, windowVisible. However, two of them differ: availablebuttons, availablegamevariables.
Keyword can be written in both underscore and camel notation (case-insensitive). 


Value should be placed after '=' sign. File paths should not be placed between "" marks like the rest of the string values.
\begin{cblock}
...
#Values
living_reward = -1
render_crosshair = false
#Path
doom_iwad_path = ../../scenarios/doom2.wad
doom_file_path = ../../scenarios/basic.wad
#Normal String
doom_map = "map01"
...
\end{cblock}
Enum values should be passed using their name.
\begin{cblock}
...
#Enums
screen_format = CRCGCB
mode = PLAYER
...
\end{cblock}
Each setting should be separated from each other by a sign of the new line. In order to improve readability, it's possible to add a comment line by adding a '\#' sign at the beginning of the new line.

An exceptionally behave here availablebuttons and availablegamevariables functions because instead of individual variables, take as an argument the list of values in '\{\}'. The individual components should be separated from each other by a newline.
\begin{cblock}
...
# Available buttons
available_buttons = 
	{ 
		MOVE_LEFT 
		MOVE_RIGHT 
		ATTACK 
	}
# Game variables that will be in the state
available_game_variables = { AMMO2}
...
\end{cblock}

\section{Wrappers}
\subsection{Python}

Python functions and metods are very similar to the c++ ones. Howewer, because of the language differences, some of the values may vary. All differences are listed below.

\paragraph {Naming}
Naming convention used in python binding is underscore. The only exception is the constructor which is named in the same way like in c++.

\begin{cblock}
c++: DoomFixedToDouble(int doomFixed)
python: doom_fixed_to_double(int doomFixed)
\end{cblock}


\paragraph {Structures}
 State is changed structuraly: bufer is a numpy array and game variables are contained in a Python list. Whats more, getState() copies the buffer and gameVariables what doesn't happen in cpp. 
\paragraph {Enumerations}
Python equivalent of enums were created with the same names.
\paragraph {Types}
Due to the languages differences, some types have been modified.
\begin{itemize} 
\item Vectors in all functions were changed to python lists of compatible type.

\item  uint8\_t, unsigned int, size\_t were changed to int
\end{itemize}



\subsection{Java}
Java, like python, is a bit different then c++. All differences and the most important principles of using are listed below.

\paragraph {Naming}
 Naming convention is camelcase 
\begin{clinee}
c++: DoomFixedToDouble(int doomFixed)
java: DoomFixedToDouble(int doomFixed)
\end{clinee}
\paragraph {Structures}
State is changed structuraly: bufer and game variables are int tables (int[]). Whats more, getState copies the buffer and gameVariables, it doesn't happen in cpp. 
\paragraph {Enumerations}
 Enumerations were created the same like in c++ (you have to use them like in java:)
\begin{clinee}
 dg.addAvailableButton(Button.ATTACK);
\end{clinee}
\paragraph {Types}
Due to the languages differences, some types have been modified.
\begin{itemize}
\item Vectors in all functions were changed to java tables of compatible type (vector<int> = int[]).
\item uint8\_t, unsigned int, size\_t were changed to int
\end{itemize}
\section{Extended Examples}
